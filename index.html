<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holyrood Election Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        .lucide-icon {
            display: inline-block;
            vertical-align: middle;
        }
        .hide-button {
            cursor: pointer;
            color: #ef4444;
            font-weight: bold;
            font-size: 1.2rem;
            padding: 0 0.5rem;
            transition: color 0.2s;
        }
        .hide-button:hover {
            color: #b91c1c;
        }
        .rag-dot {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .rag-red { background-color: #ef4444; }
        .rag-amber { background-color: #f97316; }
        .rag-green { background-color: #22c55e; }
        .filter-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .filter-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -1.px rgba(0, 0, 0, 0.06);
        }
        .filter-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom class for hidden rows */
        .hidden-row {
            display: none;
        }
        /* Ensure <b> tags are always bold */
        b {
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 min-h-screen">
    <div class="max-w-4xl mx-auto w-full bg-white rounded-2xl shadow-xl overflow-hidden p-8 space-y-8">
        <header class="text-center space-y-2">
            <h1 class="text-4xl font-bold text-gray-800 tracking-tight">
                Holyrood Election Simulator
            </h1>
            <p class="text-gray-500">
                Predicting outcomes for the Holyrood elections using latest and historical polling data
            </p>
            <!-- Removed the red disclaimer text -->
        </header>

        <!-- Methodology Section -->
        <details class="bg-gray-50 p-6 rounded-xl border border-gray-200 group">
            <summary class="text-xl font-semibold flex items-center gap-2 text-gray-700 cursor-pointer">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500 group-open:rotate-90 transition-transform"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                Methodology
            </summary>
            <div class="mt-3 text-sm text-gray-600 methodology-content">
                <p>This simulator uses a <b>Monte Carlo simulation</b> to predict the election outcome. It runs <b>20,000 individual simulations</b>, each representing a possible election day scenario. For each simulation, poll numbers are adjusted based on historical "polling trend" data and a random "jitter" to account for natural polling variability.</p>
               
                <h3 class="font-semibold mt-4 text-gray-700">How Votes are Converted to Seats:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li><b>Constituency Seats (73 seats):</b> These are allocated using a simplified <b>First-Past-the-Post (FPTP) proxy</b>. The party with the highest percentage of votes in a simulated constituency vote is assumed to win a proportional number of seats, with remaining seats distributed based on highest fractional remainders. This is a simplification, as actual FPTP is constituency-by- constituency.</li>
                    <li><b>Regional List Seats (56 seats):</b> These are allocated using the <b>D'Hondt method</b>, a proportional representation system. The D'Hondt method aims to balance the overall seat distribution by giving "top-up" seats to parties that may have been underrepresented in the constituency vote. It works by iteratively dividing each party's regional vote total by a divisor (initially 1, then 2, 3, etc., incrementing each time a party wins a seat) and allocating seats to the party with the highest resulting quotient.</li>
                </ul>

                <h3 class="font-semibold mt-4 text-gray-700">Polling Trends & Jitter:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li><b>Rolling Average:</b> The simulation starts with a rolling average of the <b>last 5 polls</b> to establish a baseline for party support.</li>
                    <li><b>Jitter:</b> A random "jitter" is added to each party's poll number in every simulation. This jitter is proportional to the party's average share, meaning larger parties will have smaller, more stable swings, while smaller parties can experience more volatile (but still realistic) fluctuations. This helps simulate the inherent uncertainty in polling.</li>
                    <li><b>Historical Trends:</b> The simulation incorporates an <b>averaged historical trend</b> derived from the 1999, 2003, 2007, 2011, 2016, and 2021 Scottish Parliament elections. For each historical election, a <b>weighted average of all pre-election polls</b> is calculated (giving more weight to polls closer to the election date). The trend for that election is then the difference between the actual election result and this weighted average of pre-election polls. These individual election trends are then averaged, with <b>more recent election years receiving a higher weight</b>, to create the overall historical trend applied to current polling.</li>
                </ul>
               
                <h3 class="font-semibold mt-4 text-gray-700">Important Notes:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li>The "Others" party acts as a general category for smaller parties and independents. Its votes contribute to seat allocation but it is not considered for explicit coalition formation.</li>
                    <li>For simplicity, the model applies national polling trends and does not account for specific regional variations in voter swings or local constituency dynamics.</li>
                </ul>
            </div>
        </details>

        <!-- Latest Polls Section -->
        <details class="space-y-4 bg-gray-50 p-6 rounded-xl border border-gray-200 group"> <!-- Removed 'open' to make it minimized by default -->
            <summary class="text-xl font-semibold flex items-center gap-2 text-gray-700 cursor-pointer">
                <!-- Updated icon to a graph-related one -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-indigo-500 group-open:rotate-90 transition-transform"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>
                Latest Polls <!-- Renamed from Current Polls Being Used -->
            </summary>
            <div class="mt-3 text-sm text-gray-600 space-y-4">
                <div id="current-polls-table-container" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th rowspan="2" scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Poll Date
                                </th>
                                <th rowspan="2" scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Pollster
                                </th>
                                <th colspan="8" scope="colgroup" class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200">
                                    Constituency Results (%)
                                </th>
                                <th colspan="8" scope="colgroup" class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200">
                                    Regional Results (%)
                                </th>
                            </tr>
                            <tr id="party-headers-row">
                                <!-- Party headers will be generated by JavaScript -->
                            </tr>
                        </thead>
                        <tbody id="current-polls-table-body" class="bg-white divide-y divide-gray-200">
                            <!-- Poll data rows will be rendered here by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div id="current-polls-message" class="text-center text-sm font-semibold h-5 mt-4"></div>
            </div>
        </details>

        <!-- Data Input Section -->
        <details class="space-y-4 bg-white p-6 rounded-xl border border-gray-200 group">
            <summary class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center cursor-pointer">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-emerald-500 group-open:rotate-90 transition-transform"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
                Add a New Poll (Optional)
            </summary>
            <p class="text-center text-gray-500 text-sm">
                Enter the vote percentages for a new poll. If left blank, the simulator will use the last 5 polls in its database.
            </p>
            <div id="poll-message-container" class="text-center text-sm font-semibold h-5 mb-2"></div>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="space-y-4">
                    <h3 class="text-xl font-semibold flex items-center gap-2 text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-green-500"><path d="M3 3v18h18"/><path d="M7 16l4-7 4 7 5-7"/></svg>
                        Constituency Vote %
                    </h3>
                    <div id="new-constituency-inputs" class="space-y-4">
                        <!-- Inputs will be generated here by JavaScript -->
                    </div>
                    <div id="constituency-sum" class="text-right text-sm font-semibold">Total: <span class="constituency-total-value">0.0</span>%</div>
                </div>
               
                <div class="space-y-4">
                    <h3 class="text-xl font-semibold flex items-center gap-2 text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M12 2H2v10l9.294 9.294 9.707-9.707L12 2z"/><path d="M7.5 7.5h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                        Regional List Vote %
                    </h3>
                    <div id="new-regional-inputs" class="space-y-4">
                        <!-- Inputs will be generated here by JavaScript -->
                    </div>
                    <div id="regional-sum" class="text-right text-sm font-semibold">Total: <span class="regional-total-value">0.0</span>%</div>
                </div>
            </div>
        </details>
        
        <!-- Discounting Checkboxes - Grouped for consistency -->
        <div class="flex flex-col md:flex-row justify-center gap-4 mt-4">
            <!-- Removed the time-based filtering checkbox -->
            <div class="flex items-center space-x-2 bg-gray-50 p-3 rounded-xl border border-gray-200">
                <input type="checkbox" id="enable-trend-application" class="form-checkbox h-5 w-5 text-indigo-600 rounded-md border-gray-300" checked>
                <label for="enable-trend-application" class="text-gray-700 text-sm">Enable historical trend application</label>
            </div>
        </div>
       
        <!-- Run Simulation Button - Moved outside the details tag -->
        <div class="flex justify-center mt-4">
            <button id="run-simulation-button" class="bg-gray-900 text-white font-bold py-3 px-6 rounded-full text-lg hover:bg-gray-800 transition-colors filter-button flex items-center justify-center gap-2">
                <span id="button-text">Run Simulation</span>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </button>
        </div>

        <!-- Seats Required for a Majority - Moved here -->
        <div class="mt-8 text-center bg-blue-50 p-6 rounded-xl border border-blue-200 shadow-sm">
            <h3 class="text-lg font-semibold text-blue-700 flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                Seats Required for a Majority
            </h3>
            <p class="mt-2 text-xl font-bold text-blue-900">
                65
            </p>
        </div>

        <!-- Simulation Results Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-red-500"><line x1="4" x2="20" y1="9" y2="9"/><path d="M21 15V9a2 2 0 0 0-2-2H5a2 2 0 0 0 2 2v6a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z"/></svg>
                Simulation Results (20,000 Runs)
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Party
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Majority
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Plurality
                            </th>
                        </tr>
                    </thead>
                    <tbody id="probability-table" class="bg-white divide-y divide-gray-200">
                        <!-- Probabilities will be rendered here by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
       
        <!-- Predicted Seat Distribution Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500"><path d="M3 15v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4M12 12V2M15 5l-3-3-3 3"/></svg>
                Predicted Seat Distribution (Average of 20,000 Simulations)
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Party
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Constituency Seats (73)
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Regional Seats (56)
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Total Seats (129)
                            </th>
                        </tr>
                    </thead>
                    <tbody id="forecasted-seats-table" class="bg-white divide-y divide-gray-200">
                        <!-- Forecasted seats will be generated here by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Coalition Analysis Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                Coalition Analysis (Based on Simulations)
            </h2>
            <div class="flex justify-center space-x-4 mb-4">
                <button id="toggle-red-button" class="filter-button bg-gray-500 text-white font-bold py-2 px-4 rounded-full">
                    Show Red rated coalitions
                </button>
                <button id="toggle-amber-button" class="filter-button bg-amber-500 text-white font-bold py-2 px-4 rounded-full">
                    Hide Amber rated coalitions
                </button>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Coalition <span class="block text-gray-400 text-xs">(Av. Seats/Highest Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Political Viability
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Majority
                                <span class="block text-gray-400 text-xs">(&gt;= 65 Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Near-Majority
                                <span class="block text-gray-400 text-xs">(62-64 Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">
                                Likely Lead Party
                            </th>
                        </tr>
                    </thead>
                    <tbody id="coalition-table" class="bg-white divide-y divide-gray-200">
                        <!-- Coalition probabilities will be rendered here by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div id="coalition-message" class="text-center text-sm font-semibold h-5 mt-4"></div>
        </div>
       
        <!-- Key Takeaways Section -->
        <div class="space-y-4 bg-purple-50 p-6 rounded-xl border border-purple-200 shadow-sm">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center text-purple-700">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                Key Takeaways from Simulation
            </h2>
            <ul id="key-takeaways-list" class="list-disc list-inside ml-4 text-gray-800 space-y-2">
                <!-- Key takeaways will be rendered here by JavaScript -->
            </ul>
        </div>
    </div>

    <script>
        // Wrap the entire script in an IIFE to encapsulate variables and avoid global scope issues
        (function() {
            // Fixed reference date for historical trend discounting (August 10, 2025, 00:00:00 UTC)
            // This is now only used for the label text, not for calculation.
            const startDateForDiscounting = new Date('2025-08-10T00:00:00Z');
            const millisecondsPerDay = 1000 * 60 * 60 * 24;

            // Global variable to store the averaged historical trend
            let averagedHistoricalTrend = { constituency: {}, regional: {} };
            // Global variable to store the actual current polls being used (full objects with dates)
            let currentPollsInUse = [];
            // Global variable to store the new, statistically calculated jitters
            let calculatedJitterFactors = {};
            
            document.addEventListener('DOMContentLoaded', async () => {
                // Updated party names and colors/jitter factors based on your specified headings
                const parties = [
                    { name: 'SNP', color: '#FDF38E', jitterFactor: 0 },
                    { name: 'Labour', color: '#E4003B', jitterFactor: 0 },
                    { name: 'Conservative', color: '#0187DC', jitterFactor: 0 },
                    { name: 'Green', color: '#65D56E', jitterFactor: 0 },
                    { name: 'Liberal Democrat', color: '#FAA61A', jitterFactor: 0 },
                    { name: 'Alba', color: 'navy', jitterFactor: 0 }, 
                    { name: 'Reform', color: '#12B2E6', jitterFactor: 0 },
                    { name: 'Others', color: '#CCCCCC', jitterFactor: 0 }
                ];

                // Define aliases for party names to handle variations in sheet headers
                const partyHeaderAliases = {
                    'SNP': 'SNP',
                    'Lab': 'Labour',
                    'Labour': 'Labour',
                    'Con': 'Conservative', 
                    'Cons': 'Conservative', 
                    'Conservative': 'Conservative', 
                    'Conservatives': 'Conservative', 
                    'Greens': 'Green',
                    'Green': 'Green', 
                    'Lib Dem': 'Liberal Democrat',
                    'Lib Dems': 'Liberal Democrat', 
                    'Liberal Democrats': 'Liberal Democrat',
                    'Alba': 'Alba',
                    'Ref': 'Reform',
                    'Ref UK': 'Reform', 
                    'Reform': 'Reform', 
                    'Others': 'Others',
                    'Other': 'Others' 
                };

                // --- Constants and DOM Elements ---
                // The URL of your deployed Google Apps Script Web App acting as a CORS proxy.
                const appsScriptProxyUrl = "https://script.google.com/macros/s/AKfycbyermTNMtQ--T-Rpg0ylE4ooPvLj3IwtixyqBooJU-eXK7xFtLWNXIG80Y1mYOMJSYnhw/exec";
               
                // Current Polls GIDs (These are the GIDs for your *cleaned* sheets)
                const constituencyGid = '1550759519'; 
                const regionalGid = '182062955';   

                // Historical Election GIDs (These are the GIDs for your *manually cleaned and published* historical sheets)
                // Added a "result" property to each historical election object
                const historicalElectionGids = [
                    { year: 2021, constituencyGid: '819802892', regionalGid: '1188969757', electionDate: new Date('2021-05-06T00:00:00Z'), yearWeight: 1.0, resultGid: '1692290060' },
                    { year: 2016, constituencyGid: '718925928', regionalGid: '89652159', electionDate: new Date('2016-05-05T00:00:00Z'), yearWeight: 0.8, resultGid: '1138865612' },
                    { year: 2011, constituencyGid: '1485069294', regionalGid: '274836084', electionDate: new Date('2011-05-05T00:00:00Z'), yearWeight: 0.6, resultGid: '861788225' },
                    { year: 2007, constituencyGid: '1481565062', regionalGid: '1549024075', electionDate: new Date('2007-05-03T00:00:00Z'), yearWeight: 0.4, resultGid: '1211756088' },
                    { year: 2003, constituencyGid: '1481565062', regionalGid: '1549024075', electionDate: new Date('2003-05-01T00:00:00Z'), yearWeight: 0.2, resultGid: '1696236636' }
                ];
                

                const totalConstituencySeats = 73;
                const totalRegionalSeats = 56;
                const totalParliamentSeats = 129;
                const majoritySeats = Math.floor(totalParliamentSeats / 2) + 1;
                const nearMajoritySeats = 62; 
                const numSimulations = 20000; 
                const mainParties = parties.filter(p => p.name !== 'Others').map(p => p.name);

                const newConstituencyInputsDiv = document.getElementById('new-constituency-inputs');
                const newRegionalInputsDiv = document.getElementById('new-regional-inputs');
                const runSimulationButton = document.getElementById('run-simulation-button');
                const probabilityTableBody = document.getElementById('probability-table');
                const coalitionTableBody = document.getElementById('coalition-table');
                const forecastedSeatsTableBody = document.getElementById('forecasted-seats-table');
                const majoritySeatsEl = document.querySelector('.mt-8 p');
                const toggleRedButton = document.getElementById('toggle-red-button');
                const toggleAmberButton = document.getElementById('toggle-amber-button');
                const buttonTextSpan = document.getElementById('button-text');
                const loadingSpinner = document.getElementById('loading-spinner');
                const pollMessageContainer = document.getElementById('poll-message-container');
                const constituencySumSpan = document.querySelector('.constituency-total-value');
                const regionalSumSpan = document.querySelector('.regional-total-value');
                const keyTakeawaysList = document.getElementById('key-takeaways-list');
                const enableTrendApplicationCheckbox = document.getElementById('enable-trend-application'); 

                // New DOM elements for current polls dropdown
                const currentPollsTableBody = document.getElementById('current-polls-table-body'); 
                const partyHeadersRow = document.getElementById('party-headers-row'); 
                const currentPollsMessageDiv = document.getElementById('current-polls-message'); 
                const coalitionMessageDiv = document.getElementById('coalition-message'); 

                let coalitionData = []; 
                let hiddenRed = true; 
                let hiddenAmber = false;

                // Global storage for last simulation results to be used by takeaways
                let lastSimResults = {
                    majorityProbabilities: {},
                    pluralityProbabilities: {},
                    averageSeats: {},
                    coalitionsToRender: []
                };

                // --- Data Fetching and Parsing Functions ---
                // Added requireDate parameter to control strictness of date column requirement
                // Modified to also look for 'Pollster' column
                const parseGoogleSheetData = (csvText, requireDate = false, sheetName = "Unknown Sheet") => { 
                    console.log(`--- Parsing CSV for ${sheetName} ---`);
                    console.log("Raw CSV Text:", csvText.substring(0, 200) + (csvText.length > 200 ? '...' : '')); 

                    const polls = [];
                    const lines = csvText.split('\n');
                    if (lines.length <= 1) {
                        console.warn(`[${sheetName}] CSV has too few lines (<= 1). Returning empty array.`);
                        return [];
                    }

                    let headerRowIndex = -1;
                    let rawHeaders = [];
                    let dateColumnIndex = -1;
                    let pollsterColumnIndex = -1; 

                    for (let i = 0; i < lines.length; i++) {
                        const currentLine = lines[i].trim();
                        if (!currentLine) continue;

                        const tempHeaders = currentLine.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(h => h.trim().replace(/^"|"$/g, ''));
                       
                        const recognizedPartyCount = parties.some(p => {
                            if (tempHeaders.includes(p.name)) return true;
                            return Object.keys(partyHeaderAliases).some(alias => partyHeaderAliases[alias] === p.name && tempHeaders.includes(alias));
                        });

                        // Specifically look for "Dates conducted" for the date column
                        dateColumnIndex = tempHeaders.findIndex(h => h.toLowerCase() === 'dates conducted'); 
                        pollsterColumnIndex = tempHeaders.findIndex(h => h.toLowerCase() === 'pollster'); 
                       
                        if (recognizedPartyCount && (!requireDate || (dateColumnIndex !== -1 || pollsterColumnIndex !== -1 || sheetName.includes('Result')))) {
                            // The `|| sheetName.includes('Result')` part is important for historical results sheets
                            headerRowIndex = i;
                            rawHeaders = tempHeaders;
                            console.log(`[${sheetName}] Detected header row at index ${i}:`, rawHeaders);
                            if (requireDate && (dateColumnIndex === -1 && !sheetName.includes('Result'))) {
                                console.warn(`[${sheetName}] WARNING: Date column required but not found in detected header for historical data.`);
                            }
                            break;
                        }
                    }

                    if (headerRowIndex === -1) {
                        console.warn(`[${sheetName}] Could not find a valid header row with recognized party names. Returning empty array.`);
                        return [];
                    }

                    const headerMap = {};
                    rawHeaders.forEach((h, i) => {
                        const canonicalName = partyHeaderAliases[h];
                        if (canonicalName) {
                            headerMap[canonicalName] = i;
                        }
                    });
                    console.log(`[${sheetName}] Normalized Header Map:`, headerMap);

                    for (let i = headerRowIndex + 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) {
                            console.log(`[${sheetName}] Skipping empty line ${i+1}.`);
                            continue;
                        }

                        const rawValues = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/^"|"$/g, ''));
                        console.log(`[${sheetName}] Parsing row ${i+1} - Raw values:`, rawValues);
                       
                        const poll = { parties: {} };
                        let pollDate = null;
                        let rawDateString = ''; 
                        let pollsterName = ''; 

                        if (dateColumnIndex !== -1 && rawValues[dateColumnIndex] !== undefined) {
                            rawDateString = rawValues[dateColumnIndex].trim();
                           
                            const parsedDate = new Date(rawDateString);
                            if (!isNaN(parsedDate.getTime())) {
                                pollDate = parsedDate;
                            } else {
                               
                                console.warn(`[${sheetName}] Invalid date format in row ${i+1}: '${rawDateString}'. Date object will be null.`);
                            }
                        } else if (requireDate) {
                            console.warn(`[${sheetName}] Date column missing or empty in row ${i+1} and date is required. Skipping this poll.`);
                            continue;
                        }
                        poll.date = pollDate;
                        poll.rawDateString = rawDateString; 

                        if (pollsterColumnIndex !== -1 && rawValues[pollsterColumnIndex] !== undefined) {
                            pollsterName = rawValues[pollsterColumnIndex].trim();
                        } else if (requireDate) { 
                            console.warn(`[${sheetName}] Pollster column missing or empty in row ${i+1} and pollster is required. Skipping this poll.`);
                            continue;
                        }
                        poll.pollster = pollsterName; 

                        let hasAnyValidPartyDataInRow = false;
                        parties.forEach(p => {
                            const colIndex = headerMap[p.name];
                            let value = 0;
                            if (colIndex !== undefined && rawValues[colIndex] !== undefined && rawValues[colIndex] !== '') {
                                const cleanedValue = rawValues[colIndex].replace(/[^0-9.-]/g, '').trim();
                                const parsedValue = parseFloat(cleanedValue);
                               
                                if (!isNaN(parsedValue)) {
                                    value = parsedValue;
                                    if (value !== 0) {
                                        hasAnyValidPartyDataInRow = true;
                                    }
                                } else {
                                    if (cleanedValue !== '') {
                                        console.warn(`[${sheetName}] Party '${p.name}' data in row ${i+1} ('${rawValues[colIndex]}') is invalid (NaN after cleaning). Setting to 0.`);
                                    }
                                }
                            }
                            poll.parties[p.name] = value;
                        });

                        if (hasAnyValidPartyDataInRow) {
                            polls.push(poll);
                            console.log(`[${sheetName}] Successfully parsed poll from row ${i+1}:`, poll);
                        } else {
                            console.log(`[${sheetName}] Skipping row ${i+1}: No valid, non-zero party data found.`);
                        }
                    }
                   
                    if (requireDate) {
                        polls.sort((a, b) => (a.date ? a.date.getTime() : 0) - (b.date ? b.date.getTime() : 0));
                    }
                   
                    console.log(`--- Finished parsing CSV for ${sheetName} ---`);
                    console.log(`[${sheetName}] Final Parsed Polls:`, polls);
                    return polls;
                };
               
                const normalizeVotes = (votes) => {
                    let total = 0;
                    for (const party in votes) {
                        if (votes[party] > 0) {
                            total += votes[party];
                        }
                    }
                   
                    if (total === 0) return votes;
                    const factor = 100 / total;
                    const normalizedVotes = {};
                    for (const party in votes) {
                        const normalizedValue = votes[party] * factor;
                        normalizedVotes[party] = normalizedValue < 0 ? 0 : normalizedValue;
                    }
                    return normalizedVotes;
                };

                const fetchPollsFromGoogleSheet = async () => {
                    try {
                        console.log("Attempting to fetch current polls...");
                        // Fetch constituency data using the Apps Script proxy
                        const constituencyUrl = `${appsScriptProxyUrl}?gid=${constituencyGid}`;
                        const constituencyResponse = await fetch(constituencyUrl);
                        if (!constituencyResponse.ok) {
                            console.error(`HTTP error fetching constituency data! status: ${constituencyResponse.status}`);
                            throw new Error(`HTTP error! status: ${constituencyResponse.status}`);
                        }
                        const constituencyCsvText = await constituencyResponse.text();
                        // Current polls do not strictly require dates for their values, and we want them in sheet order
                        const constituencyPollsFull = parseGoogleSheetData(constituencyCsvText, false, "Current Constituency"); 

                        // Fetch regional data using the Apps Script proxy
                        const regionalUrl = `${appsScriptProxyUrl}?gid=${regionalGid}`;
                        const regionalResponse = await fetch(regionalUrl);
                        if (!regionalResponse.ok) {
                            console.error(`HTTP error fetching regional data! status: ${regionalResponse.status}`);
                            throw new Error(`HTTP error! status: ${regionalResponse.status}`);
                        }
                        const regionalCsvText = await regionalResponse.text();
                        // Current polls do not strictly require dates for their values, and we want them in sheet order
                        const regionalPollsFull = parseGoogleSheetData(regionalCsvText, false, "Current Regional");

                        console.log(`Current Polls: Constituency polls (full objects) length: ${constituencyPollsFull.length}, Regional polls (full objects) length: ${regionalPollsFull.length}`);
                       
                        // Combine the two data sets into a single array of poll objects, ensuring consistency
                        const combinedPollsFull = [];
                        const numPollsToConsider = Math.min(constituencyPollsFull.length, regionalPollsFull.length);

                        for (let i = 0; i < numPollsToConsider; i++) {
                            combinedPollsFull.push({
                                date: constituencyPollsFull[i].date, 
                                rawDateString: constituencyPollsFull[i].rawDateString, 
                                pollster: constituencyPollsFull[i].pollster || regionalPollsFull[i].pollster || '', 
                                constituency: normalizeVotes(constituencyPollsFull[i].parties),
                                regional: normalizeVotes(regionalPollsFull[i].parties)
                            });
                        }
                       
                        // Slice the latest 5 polls directly from the BEGINNING of the combined array, assuming sheet order is latest first
                        const finalCurrentPolls = combinedPollsFull.slice(0, 5); 
                        console.log(`Combined and sliced current polls (latest 5, based on sheet order: first 5):`, finalCurrentPolls);
                        return finalCurrentPolls; 
                    } catch (error) {
                        console.error("Could not fetch current poll data from Google Sheet. Ensure the sheets are published to web as CSV and you are running the HTML file from a web server (e.g., `http://localhost`).", error);
                        return null;
                    }
                };

                // New helper function to calculate weighted average for a set of polls
                const calculateWeightedAverageForPolls = (polls, electionDate) => {
                    const weightedSums = {};
                    let totalOverallWeight = 0;

                    parties.forEach(p => weightedSums[p.name] = 0); 

                    for (const poll of polls) {
                        if (!poll.date) {
                            console.warn(`Skipping poll due to missing date for weighted average calculation.`);
                            continue;
                        }
                        // Calculate days from poll date to election date
                        const daysBeforeElection = Math.max(0, Math.floor((electionDate.getTime() - poll.date.getTime()) / millisecondsPerDay));
                       
                        // Simple inverse weighting: polls closer to election get higher weight
                        // Add 1 to daysBeforeElection to avoid division by zero and ensure a base weight
                        const weight = 1 / (daysBeforeElection + 1); 

                        for (const partyName in poll.parties) {
                            if (parties.some(p => p.name === partyName)) { 
                                weightedSums[partyName] += (poll.parties[partyName] || 0) * weight;
                            }
                        }
                        totalOverallWeight += weight;
                    }

                    const weightedAverages = {};
                    if (totalOverallWeight === 0) {
                        // If no valid polls were found for weighted average, return zeros
                        parties.forEach(p => weightedAverages[p.name] = 0);
                        return weightedAverages;
                    }

                    parties.forEach(p => {
                        weightedAverages[p.name] = weightedSums[p.name] / totalOverallWeight;
                    });
                    return weightedAverages;
                };

                const calculateJitterFactors = async () => {
                    console.log("Calculating new jitter factors from historical data...");
                    const partyPollingErrors = {};
                    parties.forEach(p => {
                        partyPollingErrors[p.name] = { constituency: [], regional: [] };
                    });

                    for (const election of historicalElectionGids) {
                        try {
                            const prePollsUrl = `${appsScriptProxyUrl}?gid=${election.constituencyGid}`; // Use const GID as proxy
                            const resultUrl = `${appsScriptProxyUrl}?gid=${election.resultGid}`;

                            const [prePollsResponse, resultResponse] = await Promise.all([fetch(prePollsUrl), fetch(resultUrl)]);

                            if (!prePollsResponse.ok || !resultResponse.ok) {
                                console.error(`HTTP error fetching data for ${election.year}! Skipping jitter calculation for this year.`);
                                continue;
                            }
                            
                            // Parse pre-election polls for constituency and regional data
                            const prePollsConst = parseGoogleSheetData(await prePollsResponse.text(), true, `Historical Pre-Polls ${election.year}`);
                            const prePollsReg = parseGoogleSheetData(await fetch(`${appsScriptProxyUrl}?gid=${election.regionalGid}`).then(r => r.text()), true, `Historical Pre-Polls ${election.year}`);
                            
                            if (prePollsConst.length < 2 || prePollsReg.length < 2) {
                                console.warn(`Not enough pre-election polls for ${election.year} to calculate a meaningful average.`);
                                continue;
                            }

                            // Calculate weighted average of pre-election polls (excluding the result)
                            const weightedAvgConstPoll = calculateWeightedAverageForPolls(prePollsConst.slice(0, -1), election.electionDate);
                            const weightedAvgRegPoll = calculateWeightedAverageForPolls(prePollsReg.slice(0, -1), election.electionDate);

                            // Get the actual result from the last line of the result GID
                            const electionResultData = parseGoogleSheetData(await resultResponse.text(), false, `Historical Results ${election.year}`);
                            if (electionResultData.length === 0) {
                                console.warn(`Actual election results missing for ${election.year}. Skipping jitter calculation.`);
                                continue;
                            }
                            const actualResult = electionResultData[0];
                            const actualResultConst = actualResult.constituency;
                            const actualResultReg = actualResult.regional;

                            // Calculate the absolute difference for each party
                            parties.forEach(p => {
                                if (actualResultConst[p.name] !== undefined && weightedAvgConstPoll[p.name] !== undefined) {
                                    const errorConst = Math.abs(actualResultConst[p.name] - weightedAvgConstPoll[p.name]);
                                    partyPollingErrors[p.name].constituency.push(errorConst);
                                }
                                if (actualResultReg[p.name] !== undefined && weightedAvgRegPoll[p.name] !== undefined) {
                                    const errorReg = Math.abs(actualResultReg[p.name] - weightedAvgRegPoll[p.name]);
                                    partyPollingErrors[p.name].regional.push(errorReg);
                                }
                            });

                        } catch (error) {
                            console.error(`Error calculating jitter for ${election.year}:`, error);
                        }
                    }

                    // Average the errors to get the final jitter factor
                    const newJitters = {};
                    parties.forEach(p => {
                        const avgErrorConst = partyPollingErrors[p.name].constituency.length > 0 ?
                            partyPollingErrors[p.name].constituency.reduce((sum, val) => sum + val, 0) / partyPollingErrors[p.name].constituency.length : 0;
                        const avgErrorReg = partyPollingErrors[p.name].regional.length > 0 ?
                            partyPollingErrors[p.name].regional.reduce((sum, val) => sum + val, 0) / partyPollingErrors[p.name].regional.length : 0;
                        
                        // Use a simple average of the two error types for the final jitter factor
                        newJitters[p.name] = (avgErrorConst + avgErrorReg) / 2;
                        // Add a small floor to prevent jitter from being zero
                        if (newJitters[p.name] < 0.5) {
                            newJitters[p.name] = 0.5;
                        }
                        // Assign a higher default jitter for new or volatile parties without history
                        if (p.name === 'Alba' || p.name === 'Reform' || p.name === 'Green') {
                             if (newJitters[p.name] < 2.0) {
                                newJitters[p.name] = 2.0;
                             }
                        }
                    });

                    console.log("Calculated Jitter Factors:", newJitters);
                    return newJitters;
                };

                const fetchHistoricalTrends = async () => {
                    console.log("Attempting to fetch historical trends...");
                    const nextHolyroodElectionDate = new Date('2026-05-07T00:00:00Z');
                    const now = new Date();
                    const currentDaysUntilNextElection = Math.floor((nextHolyroodElectionDate.getTime() - now.getTime()) / millisecondsPerDay);
                    console.log(`Current days until next election (equivalent timeframe): ${currentDaysUntilNextElection} days`);

                    const isTrendApplicationEnabled = enableTrendApplicationCheckbox.checked; 

                    let allConstituencyTrendsSum = {};
                    let allRegionalTrendsSum = {};
                    let totalYearWeightForConst = 0; 
                    let totalYearWeightForReg = 0; 


                    parties.forEach(p => {
                        allConstituencyTrendsSum[p.name] = 0;
                        allRegionalTrendsSum[p.name] = 0;
                    });

                    for (const election of historicalElectionGids) {
                        try {
                            const constUrl = `${appsScriptProxyUrl}?gid=${election.constituencyGid}`;
                            const regUrl = `${appsScriptProxyUrl}?gid=${election.regionalGid}`;
                            const resultUrl = `${appsScriptProxyUrl}?gid=${election.resultGid}`;

                            const [constResponse, regResponse, resultResponse] = await Promise.all([fetch(constUrl), fetch(regUrl), fetch(resultUrl)]);

                            if (!constResponse.ok || !regResponse.ok || !resultResponse.ok) {
                                console.error(`HTTP error fetching historical data for ${election.year}! Skipping trends for this year.`);
                                continue; 
                            }

                            const constCsvText = await constResponse.text();
                            const regCsvText = await regResponse.text();

                            let allConstPollsForElection = parseGoogleSheetData(constCsvText, true, `Historical ${election.year} Constituency`); 
                            let allRegPollsForElection = parseGoogleSheetData(regCsvText, true, `Historical ${election.year} Regional`);
                            const electionResultData = parseGoogleSheetData(await resultResponse.text(), false, `Historical Results ${election.year}`);
                            
                            if (allConstPollsForElection.length === 0 || allRegPollsForElection.length === 0 || electionResultData.length === 0) {
                                console.warn(`Data missing for ${election.year}. Cannot calculate trend. Skipping.`);
                                continue;
                            }

                            const actualConstResult = normalizeVotes(electionResultData[0].constituency);
                            const actualRegResult = normalizeVotes(electionResultData[0].regional);

                            let pollsForWeightedAvgConst = allConstPollsForElection.filter(p => p.date && p.date.getTime() < election.electionDate.getTime());
                            let pollsForWeightedAvgReg = allRegPollsForElection.filter(p => p.date && p.date.getTime() < election.electionDate.getTime());

                            if (pollsForWeightedAvgConst.length === 0 || pollsForWeightedAvgReg.length === 0) {
                                console.warn(`No pre-election polls available for weighted average calculation for ${election.year}. Skipping trend for this year.`);
                                continue; 
                            }

                            const weightedAvgConstPoll = calculateWeightedAverageForPolls(pollsForWeightedAvgConst, election.electionDate);
                            const weightedAvgRegPoll = calculateWeightedAverageForPolls(pollsForWeightedAvgReg, election.electionDate);

                            parties.forEach(p => {
                                const constTrend = (actualConstResult[p.name] || 0) - (weightedAvgConstPoll[p.name] || 0);
                                const regTrend = (actualRegResult[p.name] || 0) - (weightedAvgRegPoll[p.name] || 0);
                               
                                allConstituencyTrendsSum[p.name] += constTrend * election.yearWeight;
                                allRegionalTrendsSum[p.name] += regTrend * election.yearWeight;
                            });
                            totalYearWeightForConst += election.yearWeight; 
                            totalYearWeightForReg += election.yearWeight; 

                        } catch (error) {
                            console.error(`Error processing historical data for ${election.year}:`, error);
                        }
                    }

                    const finalAveragedTrend = { constituency: {}, regional: {} };

                    if (isTrendApplicationEnabled && (totalYearWeightForConst > 0 || totalYearWeightForReg > 0)) { 
                        parties.forEach(p => {
                            finalAveragedTrend.constituency[p.name] = totalYearWeightForConst > 0 ? (allConstituencyTrendsSum[p.name] / totalYearWeightForConst) : 0;
                            finalAveragedTrend.regional[p.name] = totalYearWeightForReg > 0 ? (allRegionalTrendsSum[p.name] / totalYearWeightForReg) : 0;
                        });
                        console.log("Averaged Historical Trends (Weighted by Year):", finalAveragedTrend);
                    } else {
                        parties.forEach(p => {
                            finalAveragedTrend.constituency[p.name] = 0;
                            finalAveragedTrend.regional[p.name] = 0;
                        });
                        console.warn("Historical trend application is disabled or no meaningful historical trends could be loaded. Simulation will run without historical swings (trends set to 0).");
                    }
                    return finalAveragedTrend;
                };

                const updateAndRunSimulation = async () => {
                    console.log("updateAndRunSimulation started.");
                    buttonTextSpan.textContent = "Simulating...";
                    loadingSpinner.classList.remove('hidden');
                    runSimulationButton.disabled = true;
                    pollMessageContainer.textContent = "Fetching data from Google Sheet...";
                    pollMessageContainer.className = "text-center text-sm font-semibold h-5 mb-2 text-gray-600";

                    window.requestAnimationFrame(async () => {
                        try {
                            calculatedJitterFactors = await calculateJitterFactors();
                            averagedHistoricalTrend = await fetchHistoricalTrends();
                            currentPollsInUse = (await fetchPollsFromGoogleSheet()) || []; 
                            setTimeout(() => {
                                try {
                                    runMonteCarloSimulation();
                                    renderCurrentPollsTable(currentPollsInUse); 
                                    renderInputs(); // Call renderInputs to ensure new poll inputs are correctly rendered
                                    console.log("Simulation run completed successfully.");
                                } catch (simError) {
                                    console.error("Error during Monte Carlo simulation run:", simError);
                                    showTempMessage("An error occurred during simulation. Check console for details.", "text-red-500");
                                } finally {
                                    buttonTextSpan.textContent = "Run Simulation";
                                    loadingSpinner.classList.add('hidden');
                                    runSimulationButton.disabled = false;
                                }
                            }, 50); 
                        } catch (fetchError) {
                            console.error("Error during data fetching in updateAndRunSimulation:", fetchError);
                            showTempMessage("An error occurred during data loading. Check console for details.", "text-red-500");
                            buttonTextSpan.textContent = "Run Simulation";
                            loadingSpinner.classList.add('hidden');
                            runSimulationButton.disabled = false;
                            probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">Error loading data.</td></tr>`;
                            coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">Error loading data.</td></tr>`;
                            forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">Error loading data.</td></tr>`;
                            keyTakeawaysList.innerHTML = '<li class="text-gray-500">Simulation could not be run due to an unexpected error. Please check the console.</li>';
                        }
                    });
                };

                // --- Utility Functions ---

                // Generates a random number with a normal-ish distribution (Bell Curve approximation)
                // https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
                const randn_bm = () => {
                    let u = 0, v = 0;
                    while(u === 0) u = Math.random(); 
                    while(v === 0) v = Math.random();
                    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
                    num = num / 10.0 + 0.5; 
                    if (num > 1 || num < 0) return randn_bm(); 
                    return num;
                }

                const getCombinations = (arr, k) => {
                    const result = [];
                    function backtrack(combo, start) {
                        if (combo.length === k) {
                            result.push([...combo]);
                            return;
                        }
                        for (let i = start; i < arr.length; i++) {
                            combo.push(arr[i]);
                            backtrack(combo, i + 1);
                            combo.pop();
                        }
                        return result;
                    }
                    backtrack([], 0);
                    return result;
                };

                const parseNewPollFromInputs = () => {
                    const newConstituencyPoll = {};
                    const newRegionalPoll = {};
                    let hasValidData = false;
                    let constituencySum = 0;
                    let regionalSum = 0;

                    parties.forEach(p => {
                        const constInput = document.getElementById(`constituency-new-${p.name}`);
                        const regInput = document.getElementById(`regional-new-${p.name}`);
                       
                        let constValue = (constInput && constInput.value !== '') ? parseFloat(constInput.value) : 0;
                        let regValue = (regInput && regInput.value !== '') ? parseFloat(regInput.value) : 0;

                        if (isNaN(constValue) || constValue < 0) constValue = 0;
                        if (constValue > 100) constValue = 100;

                        if (isNaN(regValue) || regValue < 0) regValue = 0;
                        if (regValue > 100) regValue = 100;

                        if (constInput && constInput.value !== '') hasValidData = true; 
                        if (regInput && regInput.value !== '') hasValidData = true;

                        newConstituencyPoll[p.name] = constValue;
                        newRegionalPoll[p.name] = regValue;

                        constituencySum += constValue;
                        regionalSum += regValue;
                    });
                   
                    constituencySumSpan.textContent = constituencySum.toFixed(1);
                    regionalSumSpan.textContent = regionalSum.toFixed(1);

                    if (Math.abs(constituencySum - 100) > 0.5) { 
                        constituencySumSpan.classList.add('text-red-500');
                    } else {
                        constituencySumSpan.classList.remove('text-red-500');
                    }
                    if (Math.abs(regionalSum - 100) > 0.5) { 
                        regionalSumSpan.classList.add('text-red-500');
                    } else {
                        regionalSumSpan.classList.remove('text-red-500');
                    }

                    if (!hasValidData) return null;

                    return { constituency: newConstituencyPoll, regional: newRegionalPoll };
                };
                
                const isDuplicate = (newPoll, pollHistory, n) => {
                    const lastN = pollHistory.slice(-n);
                    return lastN.some(historicPoll => {
                        const constMatch = parties.every(p => {
                            const historicVal = historicPoll.constituency[p.name] || 0;
                            const newVal = newPoll.constituency[p.name] || 0;
                            return Math.abs(historicVal - newVal) < 0.1; 
                        });
                        const regMatch = parties.every(p => {
                            const historicVal = historicPoll.regional[p.name] || 0;
                            const newVal = newPoll.regional[p.name] || 0;
                            return Math.abs(historicVal - newVal) < 0.1; 
                        });
                        return constMatch && regMatch;
                    });
                };

                const calculateSeats = (constituencyVotes, regionalVotes) => {
                    const finalResults = parties.map(p => ({
                        ...p,
                        constituencySeats: 0,
                        regionalSeats: 0,
                        totalSeats: 0,
                        regionalVoteValue: regionalVotes[p.name] || 0,
                    }));
                   
                    let remainingConstituencySeats = totalConstituencySeats;
                    const constituencySeatAllocation = {};
                    const sortedConstituencyParties = [...finalResults].sort((a, b) => (constituencyVotes[b.name] || 0) - (constituencyVotes[a.name] || 0));

                    sortedConstituencyParties.forEach(party => {
                        const votes = constituencyVotes[party.name] || 0;
                        const seats = Math.floor((votes / 100) * totalConstituencySeats);
                        constituencySeatAllocation[party.name] = seats;
                        remainingConstituencySeats -= seats;
                    });
                   
                    if (remainingConstituencySeats > 0) {
                        const fractionalParties = sortedConstituencyParties
                            .map(party => ({
                                name: party.name,
                                fraction: (((constituencyVotes[party.name] || 0) / 100) * totalConstituencySeats) % 1
                            }))
                            .sort((a, b) => b.fraction - a.fraction);

                        for (let i = 0; i < remainingConstituencySeats; i++) {
                            if (fractionalParties[i] && constituencySeatAllocation[fractionalParties[i].name] !== undefined) {
                                constituencySeatAllocation[fractionalParties[i].name]++;
                            }
                        }
                    }
                   
                    finalResults.forEach(p => {
                        p.constituencySeats = constituencySeatAllocation[p.name] || 0;
                    });

                    let remainingRegionalSeats = totalRegionalSeats;
                    while (remainingRegionalSeats > 0) {
                        let highestValue = -1;
                        let winnerName = null;

                        for (const party of finalResults) {
                            const divisor = party.constituencySeats + party.regionalSeats + 1;
                            const value = (regionalVotes[party.name] || 0) / divisor;
                            if (value > highestValue) {
                                highestValue = value;
                                winnerName = party.name;
                            }
                        }

                        if (winnerName) {
                            const winningParty = finalResults.find(p => p.name === winnerName);
                            if (winningParty) {
                                winningParty.regionalSeats++;
                            }
                        }
                        remainingRegionalSeats--;
                    }
                   
                    finalResults.forEach(p => {
                        p.totalSeats = p.constituencySeats + p.regionalSeats;
                    });

                    return finalResults.sort((a, b) => b.totalSeats - a.totalSeats);
                };

                const getRagRating = (coalitionParties) => {
                    const hasSnp = coalitionParties.includes('SNP');
                    const hasLabour = coalitionParties.includes('Labour');
                    const hasConservative = coalitionParties.includes('Conservative');
                    const hasGreen = coalitionParties.includes('Green');
                    const hasLiberalDemocrat = coalitionParties.includes('Liberal Democrat');
                    const hasAlba = coalitionParties.includes('Alba');
                    const hasReform = coalitionParties.includes('Reform');

                    if (coalitionParties.length === 2 && hasReform && hasConservative) {
                        return 'green';
                    }

                    if (hasLabour && hasConservative) {
                        return 'red';
                    }

                    if (hasSnp && hasLabour) {
                        return 'red';
                    }

                    if (hasAlba) {
                        if (hasSnp && coalitionParties.length === 2 && coalitionParties.includes('Alba')) {
                            return 'amber';
                        } else {
                            return 'red';
                        }
                    }

                    if (hasReform) {
                        return 'red';
                    }

                    if (
                        (hasSnp && hasConservative) ||
                        (hasGreen && hasConservative)
                    ) {
                        return 'red';
                    }

                    if (
                        (hasConservative && hasLiberalDemocrat) ||
                        (hasLabour && hasGreen && hasConservative)
                    ) {
                        return 'amber';
                    }

                    return 'green';
                };

                // --- Monte Carlo Simulation ---
                const runMonteCarloSimulation = () => { 
                    console.log("runMonteCarloSimulation started.");
                    try {
                        const majorityCounter = {};
                        const pluralityCounter = {};
                        const seatTotaler = {};
                        const coalitionMajorityCounts = {}; 
                        const coalitionNearMajorityCounts = {}; 
                        const coalitionSeatTotals = {}; 
                        const coalitionMaxSeats = {}; 

                        const baseCoalitionSeniorityTracker = {}; 

                        parties.forEach(p => {
                            majorityCounter[p.name] = 0;
                            pluralityCounter[p.name] = 0;
                            seatTotaler[p.name] = { constituency: 0, regional: 0, total: 0 };
                        });

                        const coalitionParties = mainParties;
                        const twoPartyCombos = getCombinations(coalitionParties, 2);
                        const threePartyCombos = getCombinations(coalitionParties, 3);
                       
                        const allCombos = [...twoPartyCombos, ...threePartyCombos];
                        allCombos.forEach(combo => {
                            const baseCoalitionKey = [...combo].sort().join(' + '); 
                            coalitionMajorityCounts[baseCoalitionKey] = 0;
                            coalitionNearMajorityCounts[baseCoalitionKey] = 0;
                            coalitionSeatTotals[baseCoalitionKey] = 0;
                            coalitionMaxSeats[baseCoalitionKey] = 0;
                           
                            baseCoalitionSeniorityTracker[baseCoalitionKey] = { totalOccurrences: 0 };
                            combo.forEach(pName => {
                                baseCoalitionSeniorityTracker[baseCoalitionKey][pName] = 0;
                            });
                        });

                        const newPollInput = parseNewPollFromInputs();
                       
                        let pollsForSimulation = [...currentPollsInUse]; 

                        if (newPollInput && (Object.values(newPollInput.constituency).some(v => v > 0) || Object.values(newPollInput.regional).some(v => v > 0))) {
                            const normalizedNewPoll = {
                                constituency: normalizeVotes(newPollInput.constituency),
                                regional: normalizeVotes(newPollInput.regional)
                            };
                            if (!isDuplicate(normalizedNewPoll, currentPollsInUse, 3)) { 
                                pollsForSimulation.shift(); 
                                pollsForSimulation.push(normalizedNewPoll); 
                                showTempMessage("New poll added to simulation!", "text-green-600");
                            } else {
                                showTempMessage("New poll is a duplicate of recent polls and was not added.", "text-gray-500");
                            }
                        } else if (newPollInput) {
                            showTempMessage("New poll data incomplete or invalid. Using existing polls.", "text-amber-600");
                        }

                        const avgConstituency = {};
                        const avgRegional = {};
                        parties.forEach(p => {
                            avgConstituency[p.name] = pollsForSimulation.reduce((sum, poll) => sum + (poll.constituency[p.name] || 0), 0) / pollsForSimulation.length;
                            avgRegional[p.name] = pollsForSimulation.reduce((sum, poll) => sum + (poll.regional[p.name] || 0), 0) / pollsForSimulation.length;
                        });

                        const trendToApply = averagedHistoricalTrend;
                       
                        console.log("Starting Monte Carlo loops...");
                        for (let i = 0; i < numSimulations; i++) {
                            const simulatedConstituency = {};
                            const simulatedRegional = {};
                           
                            parties.forEach(p => {
                                // Now using the calculated jitter factors
                                const jitter = (randn_bm() - 0.5) * 2 * (calculatedJitterFactors[p.name] || 0.5);
                                
                                simulatedConstituency[p.name] = (avgConstituency[p.name] || 0) + (trendToApply.constituency[p.name] || 0) + jitter;
                                simulatedRegional[p.name] = (avgRegional[p.name] || 0) + (trendToApply.regional[p.name] || 0) + jitter;
                            });
                           
                            const normalizedConstituency = normalizeVotes(simulatedConstituency);
                            const normalizedRegional = normalizeVotes(simulatedRegional);
                           
                            const simulatedResults = calculateSeats(normalizedConstituency, normalizedRegional);
                            const resultsMap = simulatedResults.reduce((acc, curr) => { acc[curr.name] = curr; return acc; }, {});

                            simulatedResults.forEach(result => {
                                seatTotaler[result.name].constituency += result.constituencySeats;
                                seatTotaler[result.name].regional += result.regionalSeats;
                                seatTotaler[result.name].total += result.totalSeats;
                            });

                            if (simulatedResults.length > 0 && simulatedResults[0].totalSeats >= majoritySeats) {
                                majorityCounter[simulatedResults[0].name]++;
                            }

                            if (simulatedResults.length > 1 && simulatedResults[0].totalSeats > simulatedResults[1].totalSeats) {
                                pluralityCounter[simulatedResults[0].name]++;
                            } else if (simulatedResults.length === 1 && simulatedResults[0].totalSeats > 0) { 
                                pluralityCounter[simulatedResults[0].name]++;
                            }

                            const partiesForCoalition = mainParties; 

                            allCombos.forEach(combo => {
                                const baseCoalitionKey = [...combo].sort().join(' + '); 

                                const sortedComboBySeats = [...combo].sort((a, b) => (resultsMap[b]?.totalSeats || 0) - (resultsMap[a]?.totalSeats || 0));
                               
                                baseCoalitionSeniorityTracker[baseCoalitionKey].totalOccurrences++;
                                if (sortedComboBySeats[0]) {
                                    baseCoalitionSeniorityTracker[baseCoalitionKey][sortedComboBySeats[0]]++;
                                }

                                const coalitionTotalSeats = combo.reduce((sum, partyName) => sum + (resultsMap[partyName]?.totalSeats || 0), 0);
                               
                                coalitionSeatTotals[baseCoalitionKey] += coalitionTotalSeats;
                                if (coalitionTotalSeats > coalitionMaxSeats[baseCoalitionKey]) {
                                    coalitionMaxSeats[baseCoalitionKey] = coalitionTotalSeats;
                                }

                                if (coalitionTotalSeats >= majoritySeats) {
                                    coalitionMajorityCounts[baseCoalitionKey]++;
                                }
                                if (coalitionTotalSeats >= nearMajoritySeats && coalitionTotalSeats < majoritySeats) {
                                    coalitionNearMajorityCounts[baseCoalitionKey]++; 
                                }
                            });
                        }
                        console.log("Monte Carlo loops finished.");
                       
                        const majorityProbabilities = {};
                        const pluralityProbabilities = {};
                        const averageSeats = {};
                        const coalitionMajorityProbs = {};
                        const coalitionNearMajorityProbs = {};
                        const averageCoalitionSeats = {};

                        parties.forEach(p => {
                            majorityProbabilities[p.name] = (majorityCounter[p.name] / numSimulations * 100).toFixed(2);
                            pluralityProbabilities[p.name] = (pluralityCounter[p.name] / numSimulations * 100).toFixed(2);
                            averageSeats[p.name] = {
                                constituency: (seatTotaler[p.name].constituency / numSimulations), 
                                regional: (seatTotaler[p.name].regional / numSimulations),  
                                total: (seatTotaler[p.name].total / numSimulations)                          };
                        });
                       
                        Object.keys(coalitionSeatTotals).forEach(key => { 
                            coalitionMajorityProbs[key] = (coalitionMajorityCounts[key] / numSimulations * 100).toFixed(2);
                            coalitionNearMajorityProbs[key] = (coalitionNearMajorityCounts[key] / numSimulations * 100).toFixed(2);
                            averageCoalitionSeats[key] = (coalitionSeatTotals[key] / numSimulations); 
                        });

                        lastSimResults.majorityProbabilities = majorityProbabilities;
                        lastSimResults.pluralityProbabilities = pluralityProbabilities;
                        lastSimResults.averageSeats = averageSeats;
                       
                        const rawCoalitionsForDisplay = Object.keys(averageCoalitionSeats).map(key => { 
                            const partiesInKey = key.split(' + ');
                            const currentMaxSeats = coalitionMaxSeats[key] || 0; 
                           
                            return {
                                name: key, 
                                parties: partiesInKey,
                                baseCoalitionKey: key, 
                                majority: parseFloat(coalitionMajorityProbs[key] || 0), 
                                nearMajority: parseFloat(coalitionNearMajorityProbs[key] || 0), 
                                averageSeats: parseFloat(averageCoalitionSeats[key] || 0), 
                                maxSeats: currentMaxSeats
                            };
                        });

                        const filteredCoalitionsForDisplay = rawCoalitionsForDisplay.filter(c => c.majority > 0 || c.nearMajority > 0);

                        const nonRedundantCoalitionsForDisplay = filteredCoalitionsForDisplay.filter(coalition => {
                            for (let i = 0; i < coalition.parties.length; i++) {
                                const subCombinations = getCombinations(coalition.parties, i + 1);
                                for (const subCombo of subCombinations) {
                                    if (subCombo.length < coalition.parties.length) { 
                                        const subComboAvgSeats = subCombo.reduce((sum, partyName) => sum + (averageSeats[partyName]?.total || 0), 0); 
                                        if (subComboAvgSeats >= majoritySeats) {
                                            return false; 
                                        }
                                    }
                                }
                            }
                            return true;
                        });
                       
                        lastSimResults.coalitionsToRender = nonRedundantCoalitionsForDisplay.map(c => {
                            const sortedPartiesForDisplayName = [...c.parties].sort((a, b) => {
                                const seatsA = averageSeats[a]?.total || 0; 
                                const seatsB = averageSeats[b]?.total || 0;
                                return seatsB - seatsA;
                            });
                            const displayName = sortedPartiesForDisplayName.join(' + ');

                            return {
                                ...c,
                                displayName: displayName 
                            };
                        }).sort((a, b) => {
                            if (b.majority !== a.majority) {
                                return b.majority - a.majority;
                            }
                            if (b.nearMajority !== a.nearMajority) {
                                return b.nearMajority - a.nearMajority;
                            }
                            return b.averageSeats - a.averageSeats;
                        });

                        console.log("Rendering results...");
                        renderProbabilities(majorityProbabilities, pluralityProbabilities);
                        renderCoalitionProbabilities(coalitionMajorityProbs, coalitionNearMajorityProbs, averageCoalitionSeats, coalitionMaxSeats, averageSeats, baseCoalitionSeniorityTracker);
                        renderForecastedSeats(averageSeats);
                        renderKeyTakeaways(); 

                    } catch (error) {
                        console.error("Error during Monte Carlo simulation run (synchronous part):", error);
                        showTempMessage("An error occurred during simulation. Check console for details.", "text-red-500");
                        probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">Error during simulation.</td></tr>`;
                        coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">Error during simulation.</td></tr>`;
                        forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">Error during simulation.</td></tr>`;
                        keyTakeawaysList.innerHTML = '<li class="text-gray-500">Simulation could not be run due to an unexpected error. Please check the console.</li>';
                    }
                };

                // --- UI Rendering Functions ---

                const renderInputs = () => {
                    newConstituencyInputsDiv.innerHTML = '';
                    newRegionalInputsDiv.innerHTML = '';

                    parties.forEach(p => {
                        const constituencyRow = createInputHtml(p, 'constituency');
                        const regionalRow = createInputHtml(p, 'regional');
                        newConstituencyInputsDiv.innerHTML += constituencyRow;
                        newRegionalInputsDiv.innerHTML += regionalRow;
                    });

                    document.querySelectorAll('input[type="number"]').forEach(input => {
                        input.addEventListener('input', () => {
                            parseNewPollFromInputs(); 
                        });
                    });
                };
                
                // This function is removed as part of the user's request.
                // const renderManualTrendInputs = () => {
                //     manualTrendConstDiv.innerHTML = '';
                //     manualTrendRegDiv.innerHTML = '';
                //     let constTrendSum = 0;
                //     let regTrendSum = 0;

                //     const sortedParties = [...parties].sort((a,b) => a.name.localeCompare(b.name));

                //     sortedParties.forEach(p => {
                //         const jitterFactor = calculatedJitterFactors[p.name] || 0;
                //         const defaultConstTrend = averagedHistoricalTrend.constituency[p.name] || 0;
                //         const defaultRegTrend = averagedHistoricalTrend.regional[p.name] || 0;
                        
                //         constTrendSum += defaultConstTrend;
                //         regTrendSum += defaultRegTrend;

                //         const constInputHtml = createTrendInputHtml(p, 'constituency', defaultConstTrend);
                //         const regInputHtml = createTrendInputHtml(p, 'regional', defaultRegTrend);

                //         manualTrendConstDiv.innerHTML += constInputHtml;
                //         manualTrendRegDiv.innerHTML += regInputHtml;
                //     });

                //     manualTrendConstSumSpan.textContent = constTrendSum.toFixed(1);
                //     manualTrendRegSumSpan.textContent = regTrendSum.toFixed(1);
                    
                //     document.querySelectorAll('details #manual-constituency-trends input, details #manual-regional-trends input').forEach(input => {
                //         input.addEventListener('input', () => {
                //             parseManualTrendsFromInputs();
                //         });
                //     });
                // };

                const createInputHtml = (p, type) => `
                    <div class="flex items-center space-x-4 bg-gray-50 p-3 rounded-lg border border-gray-200">
                        <div class="w-4 h-4 rounded-full" style="background-color: ${p.color};"></div>
                        <label for="${type}-new-${p.name}" class="flex-1 font-medium text-gray-700">${p.name}</label>
                        <div class="flex items-center gap-2">
                            <input
                                id="${type}-new-${p.name}"
                                type="number"
                                step="0.1"
                                min="0"
                                max="100"
                                placeholder="e.g. 35.2"
                                class="w-24 text-center rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                            />
                            <span class="text-gray-500">%</span>
                        </div>
                    </div>
                `;

                const renderProbabilities = (majorityProbabilities, pluralityProbabilities) => {
                    if (!majorityProbabilities || Object.keys(majorityProbabilities).length === 0) {
                        probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">No data available for simulation.</td></tr>`;
                        return;
                    }
                   
                    probabilityTableBody.innerHTML = '';
                    const sortedParties = parties.map(p => ({
                        ...p,
                        majorityProb: parseFloat(majorityProbabilities[p.name]),
                        pluralityProb: parseFloat(pluralityProbabilities[p.name])
                    })).filter(p => p.majorityProb > 0 || p.pluralityProb > 0).sort((a, b) => b.pluralityProb - a.pluralityProb);

                    if (sortedParties.length === 0) {
                        probabilityTableBody.innerHTML = `
                            <tr class="text-center text-gray-500 italic">
                                <td colspan="3" class="px-6 py-4">No parties have a statistical chance of winning a majority or plurality based on the simulation.</td>
                            </tr>
                        `;
                        return;
                    }

                    sortedParties.forEach(p => {
                        const row = `
                            <tr class="hover:bg-gray-50 transition-colors">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0 h-4 w-4 rounded-full" style="background-color: ${p.color};"></div>
                                        <div class="ml-3 text-sm font-medium text-gray-900">${p.name}</div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${p.majorityProb}%
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${p.pluralityProb}%

                                </td>
                            </tr>
                        `;
                        probabilityTableBody.innerHTML += row;
                    });
                };
               
                const renderCoalitionProbabilities = (coalitionMajorityProbs, coalitionNearMajorityProbs, averageCoalitionSeats, coalitionMaxSeats, individualAvgSeats, baseCoalitionSeniorityTracker) => {
                    // Always clear the message div before re-rendering
                    coalitionMessageDiv.textContent = ''; 

                    const coalitionsToRender = lastSimResults.coalitionsToRender;
                   
                    if (!coalitionsToRender || coalitionsToRender.length === 0) {
                        coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">No data available for simulation.</td></tr>`;
                        updateCoalitionMessage(); 
                        return;
                    }

                    // Fix: Corrected typo from 'coalitionsTableBody' to 'coalitionTableBody'
                    coalitionTableBody.innerHTML = ''; 

                    coalitionsToRender.forEach(coalition => {
                        const ragRating = getRagRating(coalition.parties);
                        // Apply hidden-row class based on filter state
                        const hiddenClass = ((hiddenRed && ragRating === 'red') || (hiddenAmber && ragRating === 'amber')) ? 'hidden-row' : '';
                       
                        // Generate seniority breakdown HTML
                        let seniorityHtml = '';
                        const seniorityInfo = baseCoalitionSeniorityTracker[coalition.baseCoalitionKey];
                        if (seniorityInfo && seniorityInfo.totalOccurrences > 0) {
                            // Sort parties by their count within this specific seniorityInfo for display
                            const sortedSeniorityParties = Object.keys(seniorityInfo).filter(pName => pName !== 'totalOccurrences').sort((a, b) => seniorityInfo[b] - seniorityInfo[a]);
                            seniorityHtml = sortedSeniorityParties.map(pName => {
                                const prob = ((seniorityInfo[pName] / seniorityInfo.totalOccurrences) * 100).toFixed(1);
                                return `<div class="flex items-center justify-between text-xs text-gray-600"><span>${pName}:</span> <span>${prob}%</span></div>`;
                            }).join('');
                        } else {
                            seniorityHtml = '<span class="text-gray-400 text-xs">N/A</span>';
                        }


                        const row = `
                            <tr class="hover:bg-gray-50 transition-colors ${hiddenClass}" data-rag-rating="${ragRating}">
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                    ${coalition.displayName} <span class="text-gray-500 font-normal">(${coalition.averageSeats.toFixed(2)} / ${coalition.maxSeats})</span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center">
                                    <span class="rag-dot rag-${ragRating}"></span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${coalition.majority}%
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${coalition.nearMajority}%
                                </td>
                                <td class="px-6 py-4 text-left text-sm">
                                    ${seniorityHtml}
                                </td>
                            </tr>
                        `;
                        coalitionTableBody.innerHTML += row;
                    });
                    updateCoalitionMessage(); 
                };
               
                const renderForecastedSeats = (averageSeats) => {
                    if (!averageSeats || Object.keys(averageSeats).length === 0) {
                        forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">No data available for simulation.</td></tr>`;
                        return;
                    }

                    forecastedSeatsTableBody.innerHTML = '';
                    const sortedParties = parties.map(p => ({
                        ...p,
                        seats: averageSeats[p.name] 
                    })).sort((a, b) => parseFloat(b.seats.total) - parseFloat(a.seats.total)); 

                    if (sortedParties.length === 0) {
                        forecastedSeatsTableBody.innerHTML = `
                            <tr class="text-center text-gray-500 italic">
                                <td colspan="4" class="px-6 py-4">No seats could be allocated based on the simulation.</td>
                            </tr>
                        `;
                        return;
                    }

                    sortedParties.forEach(p => {
                        const row = `
                            <tr class="hover:bg-gray-50 transition-colors">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0 h-4 w-4 rounded-full" style="background-color: ${p.color};"></div>
                                        <div class="ml-3 text-sm font-medium text-gray-900">${p.name}</div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm text-gray-500">
                                    ${p.seats.constituency.toFixed(1)}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm text-gray-500">
                                    ${p.seats.regional.toFixed(1)}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${p.seats.total.toFixed(1)}
                                </td>
                            </tr>
                        `;
                        forecastedSeatsTableBody.innerHTML += row;
                    });
                };

                const toggleCoalitionVisibility = (rating) => {
                    const button = document.getElementById(`toggle-${rating}-button`);
                   
                    let isHidden;
                    if (rating === 'red') {
                        hiddenRed = !hiddenRed;
                        isHidden = hiddenRed;
                    } else if (rating === 'amber') {
                        hiddenAmber = !hiddenAmber;
                        isHidden = hiddenAmber;
                    }

                    const colorName = rating.charAt(0).toUpperCase() + rating.slice(1);
                    if (isHidden) {
                        button.textContent = `Show ${colorName} rated coalitions`;
                        button.classList.remove(`bg-${rating}-500`);
                        button.classList.add(`bg-gray-500`); 
                    } else {
                        button.textContent = `Hide ${colorName} rated coalitions`;
                        button.classList.add(`bg-${rating}-500`);
                        button.classList.remove('bg-gray-500');
                    }
                   
                    document.querySelectorAll(`#coalition-table tr[data-rag-rating="${rating}"]`).forEach(row => {
                        if (isHidden) {
                            row.classList.add('hidden-row');
                        } else {
                            row.classList.remove('hidden-row');
                        }
                    });
                    updateCoalitionMessage(); 
                };
               
                const sortCoalitionParties = (partyNames, averageSeats) => {
                    const partySeats = partyNames.map(name => ({
                        name,
                        seats: (averageSeats[name]?.total || 0) 
                    }));
                   
                    partySeats.sort((a, b) => b.seats - a.seats); 
                    return partySeats.map(p => p.name).join(' + '); 
                };

                const showTempMessage = (message, className) => {
                    pollMessageContainer.textContent = message;
                    pollMessageContainer.className = `text-center text-sm font-semibold h-5 mb-2 ${className}`; 
                    setTimeout(() => {
                        pollMessageContainer.textContent = '';
                        pollMessageContainer.className = `text-center text-sm font-semibold h-5 mb-2`; 
                    }, 5000); 
                };

                const renderKeyTakeaways = () => {
                    if (!lastSimResults.averageSeats || Object.keys(lastSimResults.averageSeats).length === 0) {
                        keyTakeawaysList.innerHTML = `<li class="text-gray-500">Simulation could not be run due to a data fetching error.</li>`;
                        return;
                    }

                    keyTakeawaysList.innerHTML = ''; 

                    const takeaways = [];

                    const sortedPlurality = parties.map(p => ({
                        name: p.name,
                        plurality: parseFloat(lastSimResults.pluralityProbabilities[p.name]),
                        majority: parseFloat(lastSimResults.majorityProbabilities[p.name])
                    }))
                    .sort((a, b) => b.plurality - a.plurality);

                    if (sortedPlurality.length > 0 && sortedPlurality[0].plurality > 0) {
                        const topParty = sortedPlurality[0];
                        let outcomeText = `The simulation suggests that <b>${topParty.name}</b> is most likely to emerge as the largest party in the Scottish Parliament, <b>achieving a plurality in ${topParty.plurality}% of the simulated elections</b>.`;
                        if (topParty.majority > 0) {
                            outcomeText += ` They <b>achieve a majority in ${topParty.majority}% of the simulated elections</b> (${majoritySeats} seats).`;
                        } else if (topParty.plurality > 50 && sortedPlurality.length > 1 && (topParty.plurality - sortedPlurality[1].plurality) > 10) {
                            outcomeText += ` While an outright majority is unlikely, they are strongly positioned to lead a government.`;
                        }
                        takeaways.push(outcomeText);
                    } else {
                        takeaways.push("No single party showed a clear path to winning a majority or plurality based on the simulation.");
                    }

                    const greenCoalitions = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'green');
                    const amberCoalitions = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'amber');

                    if (greenCoalitions.length > 0) {
                        const topGreen = greenCoalitions[0];
                        let coalitionText = `Forming a stable Scottish Government appears viable through coalition. The most politically viable option is a <b>${topGreen.displayName}</b> coalition, `;
                        if (topGreen.majority > 0) {
                            coalitionText += `which <b>achieves a majority in ${topGreen.majority}% of the simulated elections</b>.`;
                        } else {
                            coalitionText += `which <b>does not achieve a majority in our simulations</b>. However, it does reach a near-majority in which a minority government is feasible in <b>${topGreen.nearMajority}%</b> of the simulated elections.`;
                        }
                        takeaways.push(coalitionText);
                    } else if (amberCoalitions.length > 0) {
                        const topAmber = amberCoalitions[0];
                        let coalitionText = `Forming a majority Scottish Government may be challenging. The most likely coalition, though with some political hurdles, is a <b>${topAmber.displayName}</b> alliance, `;
                        if (topAmber.majority > 0) {
                            coalitionText += `which <b>achieves a majority in ${topAmber.majority}% of the simulated elections</b>.`;
                        } else {
                            coalitionText += `which <b>does not achieve a majority in our simulations</b>. However, it does reach a near-majority in which a minority government is feasible in <b>${topAmber.nearMajority}%</b> of the simulated elections.`;
                        }
                        takeaways.push(coalitionText);
                    } else {
                        takeaways.push("The simulations indicate significant challenges in forming a stable majority coalition in the Scottish Parliament.");
                    }

                    const sortedSeats = parties.map(p => ({
                        name: p.name,
                        totalSeats: (lastSimResults.averageSeats[p.name]?.total || 0) 
                    }))
                    .sort((a, b) => b.totalSeats - a.totalSeats);

                    if (sortedSeats.length >= 2) {
                        const leader = sortedSeats[0];
                        const second = sortedSeats[1];
                        const seatDifference = leader.totalSeats - second.totalSeats; 
                        let swingText = `The distribution of seats highlights the continued influence of regional list votes in shaping the overall composition of the Scottish Parliament.`; 

                        if (leader.totalSeats < majoritySeats) { 
                            if (seatDifference > 0) {
                                const seatsToShift = Math.ceil(seatDifference / 2); 
                               
                                const avgVotePerSeat = 100 / totalParliamentSeats; 
                                const estimatedVoteSwingNeeded = (seatsToShift * avgVotePerSeat);

                                swingText = `The race for the largest party in the Scottish Parliament is exceptionally close between <b>${leader.name}</b> (average ${leader.totalSeats.toFixed(1)} seats) and <b>${second.name}</b> (average ${second.totalSeats.toFixed(1)} seats). A swing of approximately <b>${estimatedVoteSwingNeeded.toFixed(2)}%</b> from <b>${leader.name}</b> to <b>${second.name}</b> would be needed for <b>${second.name}</b> to become the largest party.`;
                            } else {
                                swingText = `The leading parties are neck-and-neck, indicating a highly unpredictable outcome where even a small shift in votes could change the largest party.`;
                            }
                        } else {
                            swingText = `The distribution of seats highlights the continued influence of regional list votes in shaping the overall composition of the Scottish Parliament.`;
                        }
                       
                        takeaways.push(swingText);
                    } else {
                        takeaways.push("Further analysis is needed to identify key dynamics, as seat distribution is currently limited.");
                    }


                    takeaways.forEach(text => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = text;
                        keyTakeawaysList.appendChild(listItem);
                    });
                };

                const renderCurrentPollsTable = (polls) => {
                    currentPollsTableBody.innerHTML = ''; 
                    partyHeadersRow.innerHTML = ''; 

                    if (!polls || polls.length === 0) {
                        currentPollsMessageDiv.textContent = 'No current polls available to display.';
                        return;
                    }
                    currentPollsMessageDiv.textContent = ''; 

                    parties.forEach(p => {
                        partyHeadersRow.innerHTML += `<th scope="col" class="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${p.name}</th>`;
                    });
                    parties.forEach(p => {
                        partyHeadersRow.innerHTML += `<th scope="col" class="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${p.name}</th>`;
                    });

                    for (let i = polls.length - 1; i >= 0; i--) {
                        const poll = polls[i];
                        const row = document.createElement('tr');
                        row.classList.add('hover:bg-gray-50', 'transition-colors');

                        const dateCell = document.createElement('td');
                        dateCell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-sm', 'font-medium', 'text-gray-900');
                        dateCell.textContent = poll.rawDateString || 'No Date'; 
                        row.appendChild(dateCell);

                        const pollsterCell = document.createElement('td');
                        pollsterCell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-sm', 'text-gray-500');
                        pollsterCell.textContent = poll.pollster || 'N/A'; 
                        row.appendChild(pollsterCell);

                        parties.forEach(p => {
                            const cell = document.createElement('td');
                            cell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-center', 'text-sm', 'text-gray-500');
                            cell.textContent = (poll.constituency[p.name] || 0).toFixed(1) + '%';
                            row.appendChild(cell);
                        });

                        parties.forEach(p => {
                            const cell = document.createElement('td');
                            cell.classList.add('px-3', 'py-2', 'whitespace-nowrap', 'text-center', 'text-sm', 'text-gray-500');
                            cell.textContent = (poll.regional[p.name] || 0).toFixed(1) + '%';
                            row.appendChild(cell);
                        });

                        currentPollsTableBody.appendChild(row);
                    }
                };

                const updateCoalitionMessage = () => {
                    let message = '';

                    const allGreen = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'green');
                    const allAmber = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'amber');
                    const allRed = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'red'); 

                    const greenCoalitionsExist = allGreen.length > 0;
                    const amberCoalitionsExist = allAmber.length > 0;
                    const redCoalitionsExist = allRed.length > 0; 

                    const visibleRowsInTable = document.querySelectorAll('#coalition-table tr:not(.hidden-row)').length;

                    if (!greenCoalitionsExist && !amberCoalitionsExist && redCoalitionsExist && !hiddenRed) {
                        message = "No politically viable coalitions appear likely based on our simulations. This suggests a strong possibility of a second election taking place.";
                    } else if (!greenCoalitionsExist && !amberCoalitionsExist && !hiddenAmber) {
                        message = "No coalitions given a politically viability of Green or Amber could form in our simulations.";
                    } else if (!greenCoalitionsExist && hiddenRed && hiddenAmber) {
                        message = "No politically viable coalitions could form in our simulations.";
                    } else if (lastSimResults.coalitionsToRender.length === 0) {
                        message = "No data available for coalition analysis."; 
                    }
                   
                    if (visibleRowsInTable > 0) {
                        message = '';
                    }

                    coalitionMessageDiv.textContent = message;
                };
               
                runSimulationButton.addEventListener('click', updateAndRunSimulation); 
                toggleRedButton.addEventListener('click', () => toggleCoalitionVisibility('red'));
                toggleAmberButton.addEventListener('click', () => toggleCoalitionVisibility('amber'));
                enableTrendApplicationCheckbox.addEventListener('change', updateAndRunSimulation); 

                renderInputs();
                updateAndRunSimulation(); 
            });
        })(); 
    </script>
</body>
</html>


