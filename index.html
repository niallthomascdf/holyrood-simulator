<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holyrood Election Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        .lucide-icon {
            display: inline-block;
            vertical-align: middle;
        }
        .hide-button {
            cursor: pointer;
            color: #ef4444;
            font-weight: bold;
            font-size: 1.2rem;
            padding: 0 0.5rem;
            transition: color 0.2s;
        }
        .hide-button:hover {
            color: #b91c1c;
        }
        .rag-dot {
            height: 12px;
            width: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .rag-red { background-color: #ef4444; }
        .rag-amber { background-color: #f97316; }
        .rag-green { background-color: #22c55e; }
        .filter-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .filter-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.1), 0 4px 6px -1px rgba(0, 0, 0, 0.06);
        }
        .filter-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden-row {
            display: none;
        }
        b {
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 min-h-screen">
    <div class="max-w-4xl mx-auto w-full bg-white rounded-2xl shadow-xl overflow-hidden p-8 space-y-8">
        <header class="text-center space-y-2">
            <h1 class="text-4xl font-bold text-gray-800 tracking-tight">
                Holyrood Election Simulator
            </h1>
            <p class="text-gray-500">
                Predicting outcomes for the Holyrood elections using latest and historical polling data
            </p>
        </header>

        <!-- Methodology Section -->
        <details class="bg-gray-50 p-6 rounded-xl border border-gray-200 group">
            <summary class="text-xl font-semibold flex items-center gap-2 text-gray-700 cursor-pointer">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500 group-open:rotate-90 transition-transform"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                Methodology
            </summary>
            <div class="mt-3 text-sm text-gray-600 methodology-content">
                <p>This simulator uses a <b>Monte Carlo simulation</b> to predict the election outcome. It runs <b>20,000 individual simulations</b>, each representing a possible election day scenario. For each simulation, poll numbers are adjusted based on historical "polling trend" data and a random "jitter" to account for natural polling variability.</p>
                
                <h3 class="font-semibold mt-4 text-gray-700">How Votes are Converted to Seats:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li><b>Constituency Seats (73 seats):</b> These are allocated using a simplified <b>First-Past-the-Post (FPTP) proxy</b>. The party with the highest percentage of votes in a simulated constituency vote is assumed to win a proportional number of seats, with remaining seats distributed based on highest fractional remainders. This is a simplification, as actual FPTP is constituency-by- constituency.</li>
                    <li><b>Regional List Seats (56 seats):</b> These are allocated using the <b>D'Hondt method</b>, a proportional representation system. The D'Hondt method aims to balance the overall seat distribution by giving "top-up" seats to parties that may have been underrepresented in the constituency vote.</li>
                </ul>

                <h3 class="font-semibold mt-4 text-gray-700">Polling Trends & Jitter:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li><b>Rolling Average:</b> The simulation starts with a rolling average of the <b>last 5 polls</b> to establish a baseline for party support.</li>
                    <li><b>Jitter (Holyrood Methodology):</b> A random "jitter" is added to each party's poll number in every simulation. This jitter is a measure of the party's historical polling volatility, calculated as the <b>standard deviation</b> of the difference between a party's final pre-election polling average and its actual election result from past Holyrood elections. This gives a more accurate representation of each party's historical predictability.</li>
                    <li><b>Historical Trends (Holyrood Methodology):</b> The simulation incorporates an <b>averaged historical trend</b> derived from past Scottish Parliament elections. For each historical election, a <b>weighted average of all pre-election polls</b> is calculated (giving more weight to polls closer to the election date). The trend for that election is then the difference between the actual election result and this weighted average of pre-election polls. These individual election trends are then averaged, with <b>more recent election years receiving a higher weight</b>, to create the overall historical trend applied to current polling.</li>
                </ul>
                
                <h3 class="font-semibold mt-4 text-gray-700">Important Notes:</h3>
                <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                    <li>The "Others" party acts as a general category for smaller parties and independents. Its votes contribute to seat allocation but it is not considered for explicit coalition formation.</li>
                    <li>For simplicity, the model applies national polling trends and does not account for specific regional variations in voter swings or local constituency dynamics.</li>
                </ul>
            </div>
        </details>

        <!-- Latest Polls Section -->
        <details class="space-y-4 bg-gray-50 p-6 rounded-xl border border-gray-200 group">
            <summary class="text-xl font-semibold flex items-center gap-2 text-gray-700 cursor-pointer">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-indigo-500 group-open:rotate-90 transition-transform"><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></svg>
                Latest Polls
            </summary>
            <div class="mt-3 text-sm text-gray-600 space-y-4">
                <div id="current-polls-table-container" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th rowspan="2" scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Poll Date
                                </th>
                                <th rowspan="2" scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    Pollster
                                </th>
                                <th colspan="8" scope="colgroup" class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200">
                                    Constituency Results (%)
                                </th>
                                <th colspan="8" scope="colgroup" class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200">
                                    Regional Results (%)
                                </th>
                            </tr>
                            <tr id="party-headers-row">
                                <!-- Party headers will be generated by JavaScript -->
                            </tr>
                        </thead>
                        <tbody id="current-polls-table-body" class="bg-white divide-y divide-gray-200">
                            <!-- Poll data rows will be rendered here by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div id="current-polls-message" class="text-center text-sm font-semibold h-5 mt-4"></div>
            </div>
        </details>

        <!-- Data Input Section -->
        <details class="space-y-4 bg-white p-6 rounded-xl border border-gray-200 group">
            <summary class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center cursor-pointer">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-emerald-500 group-open:rotate-90 transition-transform"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
                Add a New Poll (Optional)
            </summary>
            <p class="text-center text-gray-500 text-sm">
                Enter the vote percentages for a new poll. If left blank, the simulator will use the last 5 polls in its database.
            </p>
            <div id="poll-message-container" class="text-center text-sm font-semibold h-5 mb-2"></div>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="space-y-4">
                    <h3 class="text-xl font-semibold flex items-center gap-2 text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-green-500"><path d="M3 3v18h18"/><path d="M7 16l4-7 4 7 5-7"/></svg>
                        Constituency Vote %
                    </h3>
                    <div id="new-constituency-inputs" class="space-y-4">
                        <!-- Inputs will be generated here by JavaScript -->
                    </div>
                    <div id="constituency-sum" class="text-right text-sm font-semibold">Total: <span class="constituency-total-value">0.0</span>%</div>
                </div>
                
                <div class="space-y-4">
                    <h3 class="text-xl font-semibold flex items-center gap-2 text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M12 2H2v10l9.294 9.294 9.707-9.707L12 2z"/><path d="M7.5 7.5h.01"/><path d="M16 16h.01"/><path d="M12 12h.01"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                        Regional List Vote %
                    </h3>
                    <div id="new-regional-inputs" class="space-y-4">
                        <!-- Inputs will be generated here by JavaScript -->
                    </div>
                    <div id="regional-sum" class="text-right text-sm font-semibold">Total: <span class="regional-total-value">0.0</span>%</div>
                </div>
            </div>
        </details>
        
        <!-- Discounting Checkboxes -->
        <div class="flex flex-col md:flex-row justify-center gap-4 mt-4">
            <div class="flex items-center space-x-2 bg-gray-50 p-3 rounded-xl border border-gray-200">
                <input type="checkbox" id="enable-trend-application" class="form-checkbox h-5 w-5 text-indigo-600 rounded-md border-gray-300" checked>
                <label for="enable-trend-application" class="text-gray-700 text-sm">Enable historical trend application</label>
            </div>
        </div>
        
        <!-- Run Simulation Button -->
        <div class="flex justify-center mt-4">
            <button id="run-simulation-button" class="bg-gray-900 text-white font-bold py-3 px-6 rounded-full text-lg hover:bg-gray-800 transition-colors filter-button flex items-center justify-center gap-2">
                <span id="button-text">Run Simulation</span>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </button>
        </div>

        <!-- Seats Required for a Majority -->
        <div class="mt-8 text-center bg-blue-50 p-6 rounded-xl border border-blue-200 shadow-sm">
            <h3 class="text-lg font-semibold text-blue-700 flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                Seats Required for a Majority
            </h3>
            <p class="mt-2 text-xl font-bold text-blue-900">
                65
            </p>
        </div>

        <!-- Simulation Results Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-red-500"><line x1="4" x2="20" y1="9" y2="9"/><path d="M21 15V9a2 2 0 0 0-2-2H5a2 2 0 0 0 2 2v6a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z"/></svg>
                Simulation Results (20,000 Runs)
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Party
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Majority
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Plurality
                            </th>
                        </tr>
                    </thead>
                    <tbody id="probability-table" class="bg-white divide-y divide-gray-200">
                        <!-- Probabilities will be rendered here by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Predicted Seat Distribution Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-blue-500"><path d="M3 15v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4M12 12V2M15 5l-3-3-3 3"/></svg>
                Predicted Seat Distribution (Average of 20,000 Simulations)
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Party
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Constituency Seats (73)
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Regional Seats (56)
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Total Seats (129)
                            </th>
                        </tr>
                    </thead>
                    <tbody id="forecasted-seats-table" class="bg-white divide-y divide-gray-200">
                        <!-- Forecasted seats will be generated here by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Coalition Analysis Section -->
        <div class="space-y-4">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                Coalition Analysis (Based on Simulations)
            </h2>
            <div class="flex justify-center space-x-4 mb-4">
                <button id="toggle-red-button" class="filter-button bg-gray-500 text-white font-bold py-2 px-4 rounded-full">
                    Show Red rated coalitions
                </button>
                <button id="toggle-amber-button" class="filter-button bg-amber-500 text-white font-bold py-2 px-4 rounded-full">
                    Hide Amber rated coalitions
                </button>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Coalition <span class="block text-gray-400 text-xs">(Av. Seats/Highest Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Political Viability
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Majority
                                <span class="block text-gray-400 text-xs">(&gt;= 65 Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Probability of Near-Majority
                                <span class="block text-gray-400 text-xs">(62-64 Seats)</span>
                            </th>
                            <th scope="col" class="px-6 py-3 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">
                                Likely Lead Party
                            </th>
                        </tr>
                    </thead>
                    <tbody id="coalition-table" class="bg-white divide-y divide-gray-200">
                        <!-- Coalition probabilities will be rendered here by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div id="coalition-message" class="text-center text-sm font-semibold h-5 mt-4"></div>
        </div>
        
        <!-- Key Takeaways Section -->
        <div class="space-y-4 bg-purple-50 p-6 rounded-xl border border-purple-200 shadow-sm">
            <h2 class="text-2xl font-bold flex items-center gap-2 text-center w-full justify-center text-purple-700">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon text-purple-500"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>
                Key Takeaways from Simulation
            </h2>
            <ul id="key-takeaways-list" class="list-disc list-inside ml-4 text-gray-800 space-y-2">
                <!-- Key takeaways will be rendered here by JavaScript -->
            </ul>
        </div>
    </div>

    <script>
        (function() {
            const millisecondsPerDay = 1000 * 60 * 60 * 24;

            let averagedHistoricalTrend = { constituency: {}, regional: {} };
            let currentPollsInUse = [];
            let calculatedJitterFactors = {};
            
            document.addEventListener('DOMContentLoaded', async () => {
                const parties = [
                    { name: 'SNP', color: '#FDF38E' },
                    { name: 'Labour', color: '#E4003B' },
                    { name: 'Conservative', color: '#0187DC' },
                    { name: 'Green', color: '#65D56E' },
                    { name: 'Liberal Democrat', color: '#FAA61A' },
                    { name: 'Alba', color: 'navy' }, 
                    { name: 'Reform', color: '#12B2E6' },
                    { name: 'Others', color: '#CCCCCC' }
                ];

                const partyHeaderAliases = {
                    'SNP': 'SNP',
                    'Lab': 'Labour',
                    'Labour': 'Labour',
                    'Con': 'Conservative', 
                    'Cons': 'Conservative', 
                    'Conservative': 'Conservative', 
                    'Conservatives': 'Conservative', 
                    'Greens': 'Green',
                    'Green': 'Green', 
                    'Lib Dem': 'Liberal Democrat',
                    'Lib Dems': 'Liberal Democrat', 
                    'Liberal Democrats': 'Liberal Democrat',
                    'Alba': 'Alba',
                    'Ref': 'Reform',
                    'Ref UK': 'Reform', 
                    'Reform': 'Reform', 
                    'Others': 'Others',
                    'Other': 'Others' 
                };

                // --- URLs for Google Sheets data. DO NOT CHANGE these GIDs ---
                const sheetId = "183G691mjKmxFq9bNZmo4MmeBGfUkRbZMBxmaz5PLy8k";
                const exportBaseUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
                
                // --- GIDs for current polls ---
                const constituencyGid = '1550759519'; 
                const regionalGid = '182062955';  

                // --- Historical Election GIDs ---
                const historicalElectionGids = [
                    { year: 2021, constituencyGid: '819802892', regionalGid: '1188969757', electionDate: new Date('2021-05-06T00:00:00Z'), yearWeight: 1.0 },
                    { year: 2016, constituencyGid: '718925928', regionalGid: '89652159', electionDate: new Date('2016-05-05T00:00:00Z'), yearWeight: 0.75 },
                    { year: 2011, constituencyGid: '1485069294', regionalGid: '274836084', electionDate: new Date('2011-05-05T00:00:00Z'), yearWeight: 0.5 },
                    { year: 2007, constituencyGid: '1481565062', regionalGid: '1549024075', electionDate: new Date('2007-05-03T00:00:00Z'), yearWeight: 0.25 }
                ];
                
                const totalConstituencySeats = 73;
                const totalRegionalSeats = 56;
                const totalParliamentSeats = 129;
                const majoritySeats = Math.floor(totalParliamentSeats / 2) + 1;
                const nearMajoritySeats = 62; 
                const numSimulations = 20000; 
                const mainParties = parties.filter(p => p.name !== 'Others').map(p => p.name);

                const newConstituencyInputsDiv = document.getElementById('new-constituency-inputs');
                const newRegionalInputsDiv = document.getElementById('new-regional-inputs');
                const runSimulationButton = document.getElementById('run-simulation-button');
                const probabilityTableBody = document.getElementById('probability-table');
                const coalitionTableBody = document.getElementById('coalition-table');
                const forecastedSeatsTableBody = document.getElementById('forecasted-seats-table');
                const toggleRedButton = document.getElementById('toggle-red-button');
                const toggleAmberButton = document.getElementById('toggle-amber-button');
                const buttonTextSpan = document.getElementById('button-text');
                const loadingSpinner = document.getElementById('loading-spinner');
                const pollMessageContainer = document.getElementById('poll-message-container');
                const constituencySumSpan = document.querySelector('.constituency-total-value');
                const regionalSumSpan = document.querySelector('.regional-total-value');
                const keyTakeawaysList = document.getElementById('key-takeaways-list');
                const enableTrendApplicationCheckbox = document.getElementById('enable-trend-application'); 
                const currentPollsTableBody = document.getElementById('current-polls-table-body'); 
                const partyHeadersRow = document.getElementById('party-headers-row'); 
                const currentPollsMessageDiv = document.getElementById('current-polls-message'); 
                const coalitionMessageDiv = document.getElementById('coalition-message'); 

                let hiddenRed = true; 
                let hiddenAmber = false;

                let lastSimResults = {
                    majorityProbabilities: {},
                    pluralityProbabilities: {},
                    averageSeats: {},
                    coalitionsToRender: []
                };

                // --- Data Fetching and Parsing Functions ---
                /**
                 * Parses CSV text from a Google Sheet, mapping party names to their values.
                 * @param {string} csvText - The raw CSV content.
                 * @param {string} sheetName - Name of the sheet for logging purposes.
                 * @param {number} dataStartRow - The row index to start parsing data from (0-indexed).
                 * @param {number} dataEndRow - The row index to end parsing at (exclusive).
                 */
                const parseGoogleSheetData = (csvText, sheetName = "Unknown Sheet", dataStartRow = 1, dataEndRow = -1) => {
                    const polls = [];
                    const lines = csvText.split('\n').map(l => l.trim()).filter(l => l);
                    if (lines.length < dataStartRow + 1) return [];

                    const rawHeaders = lines[0].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(h => h.trim().replace(/^"|"$/g, ''));
                    const headerMap = {};
                    rawHeaders.forEach((h, i) => {
                        const canonicalName = partyHeaderAliases[h];
                        if (canonicalName) headerMap[canonicalName] = i;
                    });

                    const dateColumnIndex = rawHeaders.findIndex(h => h.toLowerCase().includes('date'));
                    const pollsterColumnIndex = rawHeaders.findIndex(h => h.toLowerCase() === 'pollster');

                    const endRow = dataEndRow === -1 ? lines.length : dataEndRow;

                    for (let i = dataStartRow; i < endRow && i < lines.length; i++) {
                        const line = lines[i];
                        if (!line) continue;

                        const rawValues = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/^"|"$/g, ''));
                        
                        const poll = { parties: {} };
                        let pollDate = null;
                        let rawDateString = ''; 
                        let pollsterName = ''; 

                        if (dateColumnIndex !== -1 && rawValues[dateColumnIndex] !== undefined) {
                            rawDateString = rawValues[dateColumnIndex].trim();
                            const parsedDate = new Date(rawDateString);
                            if (!isNaN(parsedDate.getTime())) {
                                pollDate = parsedDate;
                            }
                        }
                        poll.date = pollDate;
                        poll.rawDateString = rawDateString; 

                        if (pollsterColumnIndex !== -1 && rawValues[pollsterColumnIndex] !== undefined) {
                            pollsterName = rawValues[pollsterColumnIndex].trim();
                        } 
                        poll.pollster = pollsterName; 

                        let hasAnyValidPartyDataInRow = false;
                        parties.forEach(p => {
                            const colIndex = headerMap[p.name];
                            let value = 0;
                            if (colIndex !== undefined && rawValues[colIndex] !== undefined && rawValues[colIndex] !== '') {
                                const cleanedValue = rawValues[colIndex].replace(/[^0-9.-]/g, '').trim();
                                const parsedValue = parseFloat(cleanedValue);
                                
                                if (!isNaN(parsedValue)) {
                                    value = parsedValue;
                                    if (value !== 0) hasAnyValidPartyDataInRow = true;
                                }
                            }
                            poll.parties[p.name] = value;
                        });

                        if (hasAnyValidPartyDataInRow) {
                            polls.push(poll);
                        }
                    }
                    
                    polls.sort((a, b) => (b.date ? b.date.getTime() : 0) - (a.date ? a.date.getTime() : 0));
                    
                    return polls;
                };

                /**
                 * Normalizes vote percentages to ensure they sum to 100%.
                 * @param {object} votes - An object with party names as keys and vote percentages as values.
                 */
                const normalizeVotes = (votes) => {
                    let total = 0;
                    for (const party in votes) {
                        if (votes[party] > 0) {
                            total += votes[party];
                        }
                    }
                    
                    if (total === 0) return votes;
                    const factor = 100 / total;
                    const normalizedVotes = {};
                    for (const party in votes) {
                        const normalizedValue = votes[party] * factor;
                        normalizedVotes[party] = normalizedValue < 0 ? 0 : normalizedValue;
                    }
                    return normalizedVotes;
                };

                const fetchPollsFromGoogleSheet = async () => {
                    try {
                        const constituencyUrl = `${exportBaseUrl}&gid=${constituencyGid}`;
                        const regionalUrl = `${exportBaseUrl}&gid=${regionalGid}`;
                        
                        const constituencyResponse = await fetch(constituencyUrl, { cache: 'no-cache' });
                        if (!constituencyResponse.ok) throw new Error(`HTTP error fetching current constituency polls! status: ${constituencyResponse.status}`);
                        const constituencyCsvText = await constituencyResponse.text();
                        
                        // The user wants to explicitly pull data from rows 2-6.
                        // In 0-indexed terms, this is dataStartRow = 1 and dataEndRow = 6.
                        const constituencyPollsFull = parseGoogleSheetData(constituencyCsvText, "Current Constituency", 1, 6); 

                        const regionalResponse = await fetch(regionalUrl, { cache: 'no-cache' });
                        if (!regionalResponse.ok) throw new Error(`HTTP error fetching current regional polls! status: ${regionalResponse.status}`);
                        const regionalCsvText = await regionalResponse.text();
                        
                        // The user wants to explicitly pull data from rows 2-6.
                        // In 0-indexed terms, this is dataStartRow = 1 and dataEndRow = 6.
                        const regionalPollsFull = parseGoogleSheetData(regionalCsvText, "Current Regional", 1, 6);
                        
                        const combinedPollsFull = [];
                        const numPollsToConsider = Math.min(constituencyPollsFull.length, regionalPollsFull.length);

                        for (let i = 0; i < numPollsToConsider; i++) {
                            combinedPollsFull.push({
                                date: constituencyPollsFull[i].date, 
                                rawDateString: constituencyPollsFull[i].rawDateString, 
                                pollster: constituencyPollsFull[i].pollster || regionalPollsFull[i].pollster || '', 
                                constituency: normalizeVotes(constituencyPollsFull[i].parties),
                                regional: normalizeVotes(regionalPollsFull[i].parties)
                            });
                        }
                        
                        const finalCurrentPolls = combinedPollsFull.slice(0, 5); 
                        return finalCurrentPolls; 
                    } catch (error) {
                        console.error("Could not fetch current poll data from Google Sheet.", error);
                        return null;
                    }
                };

                /**
                 * Calculates a weighted average of pre-election polls based on their proximity to the election date.
                 * @param {Array} polls - An array of poll objects.
                 * @param {Date} electionDate - The date of the election.
                 */
                const calculateWeightedAverageForPolls = (polls, electionDate) => {
                    const weightedSums = {};
                    let totalOverallWeight = 0;

                    parties.forEach(p => weightedSums[p.name] = 0); 

                    for (const poll of polls) {
                        if (!poll.date) continue;
                        
                        const daysBeforeElection = Math.max(0, Math.floor((electionDate.getTime() - poll.date.getTime()) / millisecondsPerDay));
                        
                        // Inverse linear weight: polls closer to the election get more weight.
                        const weight = 1 / (daysBeforeElection + 1); 

                        for (const partyName in poll.parties) {
                            if (parties.some(p => p.name === partyName)) { 
                                weightedSums[partyName] += (poll.parties[partyName] || 0) * weight;
                            }
                        }
                        totalOverallWeight += weight;
                    }

                    const weightedAverages = {};
                    if (totalOverallWeight === 0) {
                        parties.forEach(p => weightedAverages[p.name] = 0);
                        return weightedAverages;
                    }

                    parties.forEach(p => {
                        weightedAverages[p.name] = weightedSums[p.name] / totalOverallWeight;
                    });
                    return weightedAverages;
                };

                /**
                 * Calculates a historical "jitter" (standard deviation of polling error) for each party.
                 * This is used to model the uncertainty in future polling.
                 */
                const calculateJitterFactors = async () => {
                    console.log("Calculating new jitter factors from historical data...");
                    const partyPollingErrors = { constituency: {}, regional: {} };
                    parties.forEach(p => {
                        partyPollingErrors.constituency[p.name] = [];
                        partyPollingErrors.regional[p.name] = [];
                    });

                    for (const election of historicalElectionGids) {
                        try {
                            const prePollsUrlConst = `${exportBaseUrl}&gid=${election.constituencyGid}`;
                            const prePollsUrlReg = `${exportBaseUrl}&gid=${election.regionalGid}`;
                            
                            const [prePollsConstResponse, prePollsRegResponse] = await Promise.all([
                                fetch(prePollsUrlConst, { cache: 'no-cache' }), 
                                fetch(prePollsUrlReg, { cache: 'no-cache' })
                            ]);

                            if (!prePollsConstResponse.ok) {
                                throw new Error(`HTTP error fetching historical constituency data for ${election.year}! Status: ${prePollsConstResponse.status}`);
                            }
                            if (!prePollsRegResponse.ok) {
                                throw new Error(`HTTP error fetching historical regional data for ${election.year}! Status: ${prePollsRegResponse.status}`);
                            }
                            
                            const constCsvText = await prePollsConstResponse.text();
                            const regCsvText = await prePollsRegResponse.text();

                            const electionResultConstData = parseGoogleSheetData(constCsvText, `Result ${election.year} Const`, 1, 2);
                            const electionResultRegData = parseGoogleSheetData(regCsvText, `Result ${election.year} Reg`, 1, 2);
                            
                            const prePollsConst = parseGoogleSheetData(constCsvText, `Polls ${election.year} Const`, 2);
                            const prePollsReg = parseGoogleSheetData(regCsvText, `Polls ${election.year} Reg`, 2);
                            
                            if (prePollsConst.length < 2 || prePollsReg.length < 2 || electionResultConstData.length === 0 || electionResultRegData.length === 0) {
                                console.warn(`Not enough data for ${election.year} to calculate a meaningful average. Skipping.`);
                                continue;
                            }
                            
                            // FIX: The 'continue' statement above was causing a ReferenceError because the
                            // variables below were not being declared for a given loop iteration.
                            // The logic has been restructured to define and use the variables only when the
                            // required data is available.
                            const weightedAvgConstPoll = calculateWeightedAverageForPolls(prePollsConst, election.electionDate);
                            const weightedAvgRegPoll = calculateWeightedAverageForPolls(prePollsReg, election.electionDate);

                            const actualResultConst = normalizeVotes(electionResultConstData[0].parties);
                            const actualResultReg = normalizeVotes(electionResultRegData[0].parties);

                            parties.forEach(p => {
                                if (actualResultConst[p.name] !== undefined && weightedAvgConstPoll[p.name] !== undefined) {
                                    const errorConst = actualResultConst[p.name] - weightedAvgConstPoll[p.name];
                                    partyPollingErrors.constituency[p.name].push(errorConst);
                                }
                                if (actualResultReg[p.name] !== undefined && weightedAvgRegPoll[p.name] !== undefined) {
                                    const errorReg = actualResultReg[p.name] - weightedAvgRegPoll[p.name];
                                    partyPollingErrors.regional[p.name].push(errorReg);
                                }
                            });

                        } catch (error) {
                            console.error(`Error calculating jitter for ${election.year}:`, error);
                        }
                    }

                    const calculateStdDev = (arr) => {
                        if (arr.length < 2) return 0;
                        const n = arr.length;
                        const mean = arr.reduce((a, b) => a + b) / n;
                        return Math.sqrt(arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
                    };

                    const newJitters = {};
                    parties.forEach(p => {
                        const stdDevConst = calculateStdDev(partyPollingErrors.constituency[p.name]);
                        const stdDevReg = calculateStdDev(partyPollingErrors.regional[p.name]);
                        newJitters[p.name] = (stdDevConst + stdDevReg) / 2;
                    });

                    console.log("Calculated Jitter Factors (Standard Deviation):", newJitters);
                    return newJitters;
                };

                /**
                 * Fetches and calculates the historical polling trend based on past Holyrood elections.
                 * The trend is the difference between actual election results and pre-election weighted averages.
                 */
                const fetchHistoricalTrends = async () => {
                    console.log("Attempting to fetch historical trends...");
                    const isTrendApplicationEnabled = enableTrendApplicationCheckbox.checked; 

                    let allConstituencyTrendsSum = {};
                    let allRegionalTrendsSum = {};
                    let totalYearWeightForConst = 0; 
                    let totalYearWeightForReg = 0; 

                    parties.forEach(p => {
                        allConstituencyTrendsSum[p.name] = 0;
                        allRegionalTrendsSum[p.name] = 0;
                    });

                    for (const election of historicalElectionGids) {
                        try {
                            const constUrl = `${exportBaseUrl}&gid=${election.constituencyGid}`;
                            const regUrl = `${exportBaseUrl}&gid=${election.regionalGid}`;

                            const [constResponse, regResponse] = await Promise.all([fetch(constUrl, { cache: 'no-cache' }), fetch(regUrl, { cache: 'no-cache' })]);

                            if (!constResponse.ok) {
                                throw new Error(`HTTP error fetching historical constituency data for ${election.year}! Status: ${constResponse.status}`);
                            }
                            if (!regResponse.ok) {
                                throw new Error(`HTTP error fetching historical regional data for ${election.year}! Status: ${regResponse.status}`);
                            }

                            const constCsvText = await constResponse.text();
                            const regCsvText = await regResponse.text();
                            
                            const electionResultConstData = parseGoogleSheetData(constCsvText, `Result ${election.year} Const`, 1, 2);
                            const electionResultRegData = parseGoogleSheetData(regCsvText, `Result ${election.year} Reg`, 1, 2);
                            
                            let allConstPollsForElection = parseGoogleSheetData(constCsvText, `Polls ${election.year} Const`, 2); 
                            let allRegPollsForElection = parseGoogleSheetData(regCsvText, `Polls ${election.year} Reg`, 2);
                            
                            if (allConstPollsForElection.length === 0 || allRegPollsForElection.length === 0 || electionResultConstData.length === 0 || electionResultRegData.length === 0) {
                                console.warn(`Data missing for ${election.year} (pre-polls or results). Cannot calculate trend. Skipping.`);
                                continue;
                            }
                            
                            // FIX: Similar to the jitter function, this was a potential source of a ReferenceError.
                            // The logic is now correctly structured to proceed only when data is valid.
                            const actualConstResult = normalizeVotes(electionResultConstData[0].parties);
                            const actualRegResult = normalizeVotes(electionResultRegData[0].parties);

                            let pollsForWeightedAvgConst = allConstPollsForElection.filter(p => p.date && p.date.getTime() < election.electionDate.getTime());
                            let pollsForWeightedAvgReg = allRegPollsForElection.filter(p => p.date && p.date.getTime() < election.electionDate.getTime());

                            if (pollsForWeightedAvgConst.length === 0 || pollsForWeightedAvgReg.length === 0) {
                                console.warn(`No pre-election polls available for weighted average calculation for ${election.year}. Skipping trend for this year.`);
                                continue; 
                            }

                            const weightedAvgConstPoll = calculateWeightedAverageForPolls(pollsForWeightedAvgConst, election.electionDate);
                            const weightedAvgRegPoll = calculateWeightedAverageForPolls(pollsForWeightedAvgReg, election.electionDate);

                            parties.forEach(p => {
                                const constTrend = (actualConstResult[p.name] || 0) - (weightedAvgConstPoll[p.name] || 0);
                                const regTrend = (actualRegResult[p.name] || 0) - (weightedAvgRegPoll[p.name] || 0);
                                
                                allConstituencyTrendsSum[p.name] += constTrend * election.yearWeight;
                                allRegionalTrendsSum[p.name] += regTrend * election.yearWeight;
                            });
                            totalYearWeightForConst += election.yearWeight; 
                            totalYearWeightForReg += election.yearWeight; 

                        } catch (error) {
                            console.error(`Error processing historical data for ${election.year}:`, error);
                        }
                    }

                    const finalAveragedTrend = { constituency: {}, regional: {} };

                    if (isTrendApplicationEnabled && (totalYearWeightForConst > 0 || totalYearWeightForReg > 0)) { 
                        parties.forEach(p => {
                            finalAveragedTrend.constituency[p.name] = totalYearWeightForConst > 0 ? (allConstituencyTrendsSum[p.name] / totalYearWeightForConst) : 0;
                            finalAveragedTrend.regional[p.name] = totalYearWeightForReg > 0 ? (allRegionalTrendsSum[p.name] / totalYearWeightForReg) : 0;
                        });

                        console.log("Averaged Historical Trends (Holyrood Methodology):", finalAveragedTrend);
                    } else {
                        parties.forEach(p => {
                            finalAveragedTrend.constituency[p.name] = 0;
                            finalAveragedTrend.regional[p.name] = 0;
                        });
                        console.warn("Historical trend application is disabled or no meaningful historical trends could be loaded.");
                    }
                    return finalAveragedTrend;
                };

                /**
                 * Main function to trigger the entire simulation process.
                 * Fetches all necessary data and then runs the Monte Carlo simulation.
                 */
                const updateAndRunSimulation = async () => {
                    console.log("updateAndRunSimulation started.");
                    buttonTextSpan.textContent = "Simulating...";
                    loadingSpinner.classList.remove('hidden');
                    runSimulationButton.disabled = true;
                    pollMessageContainer.textContent = "Fetching data...";
                    pollMessageContainer.className = "text-center text-sm font-semibold h-5 mb-2 text-gray-600";

                    try {
                        // Fetch all data in parallel
                        [calculatedJitterFactors, averagedHistoricalTrend, currentPollsInUse] = await Promise.all([
                            calculateJitterFactors(),
                            fetchHistoricalTrends(),
                            fetchPollsFromGoogleSheet()
                        ]);

                        if (!currentPollsInUse) {
                            throw new Error("Failed to fetch current polls. Simulation cannot proceed.");
                        }

                        // Run the simulation with the fetched data
                        runMonteCarloSimulation();
                        renderCurrentPollsTable(currentPollsInUse);
                        renderInputs();
                        console.log("Simulation run completed successfully.");
                    } catch (error) {
                        console.error("Error during data fetching or simulation:", error);
                        showTempMessage("An error occurred. Check the console for details.", "text-red-500");
                        // Clear results tables
                        probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">Error loading data.</td></tr>`;
                        coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">Error loading data.</td></tr>`;
                        forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">Error loading data.</td></tr>`;
                        keyTakeawaysList.innerHTML = '<li class="text-gray-500">Simulation could not be run due to an unexpected error. Please check the console.</li>';
                    } finally {
                        buttonTextSpan.textContent = "Run Simulation";
                        loadingSpinner.classList.add('hidden');
                        runSimulationButton.disabled = false;
                    }
                };

                // --- Utility Functions ---
                /** Generates a random number with a normal (bell-curve) distribution. */
                const randn_bm = () => {
                    let u = 0, v = 0;
                    while(u === 0) u = Math.random(); 
                    while(v === 0) v = Math.random();
                    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
                    num = num / 10.0 + 0.5; 
                    if (num > 1 || num < 0) return randn_bm(); 
                    return num;
                }

                /** Returns all unique combinations of a given array of parties. */
                const getCombinations = (arr, k) => {
                    const result = [];
                    function backtrack(combo, start) {
                        if (combo.length === k) {
                            result.push([...combo]);
                            return;
                        }
                        for (let i = start; i < arr.length; i++) {
                            combo.push(arr[i]);
                            backtrack(combo, i + 1);
                            combo.pop();
                        }
                        return result;
                    }
                    backtrack([], 0);
                    return result;
                };

                /** Parses user input from the 'add a new poll' section. */
                const parseNewPollFromInputs = () => {
                    const newConstituencyPoll = {};
                    const newRegionalPoll = {};
                    let hasValidData = false;
                    let constituencySum = 0;
                    let regionalSum = 0;

                    parties.forEach(p => {
                        const constInput = document.getElementById(`constituency-new-${p.name}`);
                        const regInput = document.getElementById(`regional-new-${p.name}`);
                        
                        let constValue = (constInput && constInput.value !== '') ? parseFloat(constInput.value) : 0;
                        let regValue = (regInput && regInput.value !== '') ? parseFloat(regInput.value) : 0;

                        if (isNaN(constValue) || constValue < 0) constValue = 0;
                        if (constValue > 100) constValue = 100;

                        if (isNaN(regValue) || regValue < 0) regValue = 0;
                        if (regValue > 100) regValue = 100;

                        if (constInput && constInput.value !== '') hasValidData = true; 
                        if (regInput && regInput.value !== '') hasValidData = true;

                        newConstituencyPoll[p.name] = constValue;
                        newRegionalPoll[p.name] = regValue;

                        constituencySum += constValue;
                        regionalSum += regValue;
                    });
                    
                    constituencySumSpan.textContent = constituencySum.toFixed(1);
                    regionalSumSpan.textContent = regionalSum.toFixed(1);

                    if (Math.abs(constituencySum - 100) > 0.5) { 
                        constituencySumSpan.classList.add('text-red-500');
                    } else {
                        constituencySumSpan.classList.remove('text-red-500');
                    }
                    if (Math.abs(regionalSum - 100) > 0.5) { 
                        regionalSumSpan.classList.add('text-red-500');
                    } else {
                        regionalSumSpan.classList.remove('text-red-500');
                    }

                    if (!hasValidData) return null;

                    return { constituency: newConstituencyPoll, regional: newRegionalPoll };
                };
                
                /** Checks if a new poll is a near-duplicate of recent polls to avoid cluttering the simulation. */
                const isDuplicate = (newPoll, pollHistory, n) => {
                    const lastN = pollHistory.slice(-n);
                    return lastN.some(historicPoll => {
                        const constMatch = parties.every(p => {
                            const historicVal = historicPoll.constituency[p.name] || 0;
                            const newVal = newPoll.constituency[p.name] || 0;
                            return Math.abs(historicVal - newVal) < 0.1; 
                        });
                        const regMatch = parties.every(p => {
                            const historicVal = historicPoll.regional[p.name] || 0;
                            const newVal = newPoll.regional[p.name] || 0;
                            return Math.abs(historicVal - newVal) < 0.1; 
                        });
                        return constMatch && regMatch;
                    });
                };

                /** Calculates seat distribution based on constituency and regional votes. */
                const calculateSeats = (constituencyVotes, regionalVotes) => {
                    const finalResults = parties.map(p => ({
                        ...p,
                        constituencySeats: 0,
                        regionalSeats: 0,
                        totalSeats: 0,
                        regionalVoteValue: regionalVotes[p.name] || 0,
                    }));
                    
                    // First-Past-the-Post (FPTP) Proxy for Constituency Seats
                    let remainingConstituencySeats = totalConstituencySeats;
                    const constituencySeatAllocation = {};
                    const sortedConstituencyParties = [...finalResults].sort((a, b) => (constituencyVotes[b.name] || 0) - (constituencyVotes[a.name] || 0));

                    sortedConstituencyParties.forEach(party => {
                        const votes = constituencyVotes[party.name] || 0;
                        const seats = Math.floor((votes / 100) * totalConstituencySeats);
                        constituencySeatAllocation[party.name] = seats;
                        remainingConstituencySeats -= seats;
                    });
                    
                    // Allocate remaining seats by highest fractional remainder
                    if (remainingConstituencySeats > 0) {
                        const fractionalParties = sortedConstituencyParties
                            .map(party => ({
                                name: party.name,
                                fraction: (((constituencyVotes[party.name] || 0) / 100) * totalConstituencySeats) % 1
                            }))
                            .sort((a, b) => b.fraction - a.fraction);

                        for (let i = 0; i < remainingConstituencySeats; i++) {
                            if (fractionalParties[i] && constituencySeatAllocation[fractionalParties[i].name] !== undefined) {
                                constituencySeatAllocation[fractionalParties[i].name]++;
                            }
                        }
                    }
                    
                    finalResults.forEach(p => {
                        p.constituencySeats = constituencySeatAllocation[p.name] || 0;
                    });

                    // D'Hondt Method for Regional List Seats
                    let remainingRegionalSeats = totalRegionalSeats;
                    while (remainingRegionalSeats > 0) {
                        let highestValue = -1;
                        let winnerName = null;

                        for (const party of finalResults) {
                            const divisor = party.constituencySeats + party.regionalSeats + 1;
                            const value = (regionalVotes[party.name] || 0) / divisor;
                            if (value > highestValue) {
                                highestValue = value;
                                winnerName = party.name;
                            }
                        }

                        if (winnerName) {
                            const winningParty = finalResults.find(p => p.name === winnerName);
                            if (winningParty) {
                                winningParty.regionalSeats++;
                            }
                        }
                        remainingRegionalSeats--;
                    }
                    
                    finalResults.forEach(p => {
                        p.totalSeats = p.constituencySeats + p.regionalSeats;
                    });

                    return finalResults.sort((a, b) => b.totalSeats - a.totalSeats);
                };

                /** Assigns a political viability rating to a coalition. */
                const getRagRating = (coalitionParties) => {
                    const hasSnp = coalitionParties.includes('SNP');
                    const hasLabour = coalitionParties.includes('Labour');
                    const hasConservative = coalitionParties.includes('Conservative');
                    const hasGreen = coalitionParties.includes('Green');
                    const hasLiberalDemocrat = coalitionParties.includes('Liberal Democrat');
                    const hasAlba = coalitionParties.includes('Alba');
                    const hasReform = coalitionParties.includes('Reform');

                    if (coalitionParties.length === 2 && hasReform && hasConservative) {
                        return 'green';
                    }
                    if (hasLabour && hasConservative) {
                        return 'red';
                    }
                    if (hasSnp && hasLabour) {
                        return 'red';
                    }
                    if (hasAlba) {
                        return (hasSnp && coalitionParties.length === 2) ? 'amber' : 'red';
                    }
                    if (hasReform) {
                        return 'red';
                    }
                    if ((hasSnp && hasConservative) || (hasGreen && hasConservative)) {
                        return 'red';
                    }
                    if ((hasConservative && hasLiberalDemocrat) || (hasLabour && hasGreen && hasConservative)) {
                        return 'amber';
                    }
                    return 'green';
                };

                // --- Monte Carlo Simulation ---
                const runMonteCarloSimulation = () => { 
                    console.log("Monte Carlo Simulation started.");
                    const majorityCounter = {}, pluralityCounter = {}, seatTotaler = {};
                    const coalitionMajorityCounts = {}, coalitionNearMajorityCounts = {}, coalitionSeatTotals = {}, coalitionMaxSeats = {};
                    const baseCoalitionSeniorityTracker = {}; 

                    parties.forEach(p => {
                        majorityCounter[p.name] = 0;
                        pluralityCounter[p.name] = 0;
                        seatTotaler[p.name] = { constituency: 0, regional: 0, total: 0 };
                    });

                    const twoPartyCombos = getCombinations(mainParties, 2);
                    const threePartyCombos = getCombinations(mainParties, 3);
                    
                    const allCombos = [...twoPartyCombos, ...threePartyCombos];
                    allCombos.forEach(combo => {
                        const baseCoalitionKey = [...combo].sort().join(' + '); 
                        coalitionMajorityCounts[baseCoalitionKey] = 0;
                        coalitionNearMajorityCounts[baseCoalitionKey] = 0;
                        coalitionSeatTotals[baseCoalitionKey] = 0;
                        coalitionMaxSeats[baseCoalitionKey] = 0;
                        
                        baseCoalitionSeniorityTracker[baseCoalitionKey] = { totalOccurrences: 0 };
                        combo.forEach(pName => {
                            baseCoalitionSeniorityTracker[baseCoalitionKey][pName] = 0;
                        });
                    });

                    const newPollInput = parseNewPollFromInputs();
                    
                    let pollsForSimulation = [...currentPollsInUse]; 

                    if (newPollInput && (Object.values(newPollInput.constituency).some(v => v > 0) || Object.values(newPollInput.regional).some(v => v > 0))) {
                        const normalizedNewPoll = {
                            constituency: normalizeVotes(newPollInput.constituency),
                            regional: normalizeVotes(newPollInput.regional)
                        };
                        if (!isDuplicate(normalizedNewPoll, currentPollsInUse, 3)) { 
                            pollsForSimulation.unshift(normalizedNewPoll); 
                            pollsForSimulation = pollsForSimulation.slice(0, 5);
                            showTempMessage("New poll added to simulation!", "text-green-600");
                        } else {
                            showTempMessage("New poll is a duplicate of recent polls and was not added.", "text-gray-500");
                        }
                    } else if (newPollInput) {
                        showTempMessage("New poll data incomplete or invalid. Using existing polls.", "text-amber-600");
                    }

                    const avgConstituency = {};
                    const avgRegional = {};
                    parties.forEach(p => {
                        avgConstituency[p.name] = pollsForSimulation.reduce((sum, poll) => sum + (poll.constituency[p.name] || 0), 0) / pollsForSimulation.length;
                        avgRegional[p.name] = pollsForSimulation.reduce((sum, poll) => sum + (poll.regional[p.name] || 0), 0) / pollsForSimulation.length;
                    });

                    const trendToApply = averagedHistoricalTrend;
                    
                    for (let i = 0; i < numSimulations; i++) {
                        const simulatedConstituency = {};
                        const simulatedRegional = {};
                        
                        parties.forEach(p => {
                            const jitter = (randn_bm() - 0.5) * 2 * (calculatedJitterFactors[p.name] || 0.5);
                            
                            simulatedConstituency[p.name] = (avgConstituency[p.name] || 0) + (trendToApply.constituency[p.name] || 0) + jitter;
                            simulatedRegional[p.name] = (avgRegional[p.name] || 0) + (trendToApply.regional[p.name] || 0) + jitter;
                        });
                        
                        const normalizedConstituency = normalizeVotes(simulatedConstituency);
                        const normalizedRegional = normalizeVotes(simulatedRegional);
                        
                        const simulatedResults = calculateSeats(normalizedConstituency, normalizedRegional);
                        const resultsMap = simulatedResults.reduce((acc, curr) => { acc[curr.name] = curr; return acc; }, {});

                        simulatedResults.forEach(result => {
                            seatTotaler[result.name].constituency += result.constituencySeats;
                            seatTotaler[result.name].regional += result.regionalSeats;
                            seatTotaler[result.name].total += result.totalSeats;
                        });

                        if (simulatedResults.length > 0 && simulatedResults[0].totalSeats >= majoritySeats) {
                            majorityCounter[simulatedResults[0].name]++;
                        }

                        if (simulatedResults.length > 1 && simulatedResults[0].totalSeats > simulatedResults[1].totalSeats) {
                            pluralityCounter[simulatedResults[0].name]++;
                        } else if (simulatedResults.length === 1 && simulatedResults[0].totalSeats > 0) { 
                            pluralityCounter[simulatedResults[0].name]++;
                        }

                        allCombos.forEach(combo => {
                            const baseCoalitionKey = [...combo].sort().join(' + '); 

                            const sortedComboBySeats = [...combo].sort((a, b) => (resultsMap[b]?.totalSeats || 0) - (resultsMap[a]?.totalSeats || 0));
                            
                            baseCoalitionSeniorityTracker[baseCoalitionKey].totalOccurrences++;
                            if (sortedComboBySeats[0]) {
                                baseCoalitionSeniorityTracker[baseCoalitionKey][sortedComboBySeats[0]]++;
                            }

                            const coalitionTotalSeats = combo.reduce((sum, partyName) => sum + (resultsMap[partyName]?.totalSeats || 0), 0);
                            
                            coalitionSeatTotals[baseCoalitionKey] += coalitionTotalSeats;
                            if (coalitionTotalSeats > coalitionMaxSeats[baseCoalitionKey]) {
                                coalitionMaxSeats[baseCoalitionKey] = coalitionTotalSeats;
                            }

                            if (coalitionTotalSeats >= majoritySeats) {
                                coalitionMajorityCounts[baseCoalitionKey]++;
                            }
                            if (coalitionTotalSeats >= nearMajoritySeats && coalitionTotalSeats < majoritySeats) {
                                coalitionNearMajorityCounts[baseCoalitionKey]++; 
                            }
                        });
                    }
                    
                    const majorityProbabilities = {}, pluralityProbabilities = {}, averageSeats = {};
                    const coalitionMajorityProbs = {}, coalitionNearMajorityProbs = {}, averageCoalitionSeats = {};

                    parties.forEach(p => {
                        majorityProbabilities[p.name] = (majorityCounter[p.name] / numSimulations * 100).toFixed(2);
                        pluralityProbabilities[p.name] = (pluralityCounter[p.name] / numSimulations * 100).toFixed(2);
                        averageSeats[p.name] = {
                            constituency: (seatTotaler[p.name].constituency / numSimulations), 
                            regional: (seatTotaler[p.name].regional / numSimulations),  
                            total: (seatTotaler[p.name].total / numSimulations)    };
                    });
                    
                    Object.keys(coalitionSeatTotals).forEach(key => { 
                        coalitionMajorityProbs[key] = (coalitionMajorityCounts[key] / numSimulations * 100).toFixed(2);
                        coalitionNearMajorityProbs[key] = (coalitionNearMajorityCounts[key] / numSimulations * 100).toFixed(2);
                        averageCoalitionSeats[key] = (coalitionSeatTotals[key] / numSimulations); 
                    });

                    lastSimResults = { majorityProbabilities, pluralityProbabilities, averageSeats, baseCoalitionSeniorityTracker };
                    
                    const rawCoalitionsForDisplay = Object.keys(averageCoalitionSeats).map(key => { 
                        return {
                            name: key, 
                            parties: key.split(' + '),
                            baseCoalitionKey: key, 
                            majority: parseFloat(coalitionMajorityProbs[key] || 0), 
                            nearMajority: parseFloat(coalitionNearMajorityProbs[key] || 0), 
                            averageSeats: parseFloat(averageCoalitionSeats[key] || 0), 
                            maxSeats: coalitionMaxSeats[key] || 0
                        };
                    });

                    const filteredCoalitionsForDisplay = rawCoalitionsForDisplay.filter(c => c.majority > 0 || c.nearMajority > 0);

                    const nonRedundantCoalitionsForDisplay = filteredCoalitionsForDisplay.filter(coalition => {
                        for (let i = 0; i < coalition.parties.length; i++) {
                            const subCombinations = getCombinations(coalition.parties, i + 1);
                            for (const subCombo of subCombinations) {
                                if (subCombo.length < coalition.parties.length) { 
                                    const subComboAvgSeats = subCombo.reduce((sum, partyName) => sum + (averageSeats[partyName]?.total || 0), 0); 
                                    if (subComboAvgSeats >= majoritySeats) {
                                        return false; 
                                    }
                                }
                            }
                        }
                        return true;
                    });
                    
                    lastSimResults.coalitionsToRender = nonRedundantCoalitionsForDisplay.map(c => {
                        const sortedPartiesForDisplayName = [...c.parties].sort((a, b) => {
                            const seatsA = averageSeats[a]?.total || 0; 
                            const seatsB = averageSeats[b]?.total || 0;
                            return seatsB - seatsA;
                        });
                        return { ...c, displayName: sortedPartiesForDisplayName.join(' + ') };
                    }).sort((a, b) => {
                        if (b.majority !== a.majority) return b.majority - a.majority;
                        if (b.nearMajority !== a.nearMajority) return b.nearMajority - a.nearMajority;
                        return b.averageSeats - a.averageSeats;
                    });

                    renderProbabilities(majorityProbabilities, pluralityProbabilities);
                    renderCoalitionProbabilities();
                    renderForecastedSeats(averageSeats);
                    renderKeyTakeaways(); 

                };

                // --- UI Rendering Functions ---
                const renderInputs = () => {
                    newConstituencyInputsDiv.innerHTML = '';
                    newRegionalInputsDiv.innerHTML = '';

                    parties.forEach(p => {
                        newConstituencyInputsDiv.innerHTML += createInputHtml(p, 'constituency');
                        newRegionalInputsDiv.innerHTML += createInputHtml(p, 'regional');
                    });

                    document.querySelectorAll('input[type="number"]').forEach(input => {
                        input.addEventListener('input', parseNewPollFromInputs);
                    });
                };
                
                const createInputHtml = (p, type) => `
                    <div class="flex items-center space-x-4 bg-gray-50 p-3 rounded-lg border border-gray-200">
                        <div class="w-4 h-4 rounded-full" style="background-color: ${p.color};"></div>
                        <label for="${type}-new-${p.name}" class="flex-1 font-medium text-gray-700">${p.name}</label>
                        <div class="flex items-center gap-2">
                            <input
                                id="${type}-new-${p.name}"
                                type="number"
                                step="0.1"
                                min="0"
                                max="100"
                                placeholder="e.g. 35.2"
                                class="w-24 text-center rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                            />
                            <span class="text-gray-500">%</span>
                        </div>
                    </div>
                `;

                const renderProbabilities = (majorityProbabilities, pluralityProbabilities) => {
                    if (!majorityProbabilities || Object.keys(majorityProbabilities).length === 0) {
                        probabilityTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="3" class="px-6 py-4">No data available for simulation.</td></tr>`;
                        return;
                    }
                    
                    probabilityTableBody.innerHTML = '';
                    const sortedParties = parties.map(p => ({
                        ...p,
                        majorityProb: parseFloat(majorityProbabilities[p.name]),
                        pluralityProb: parseFloat(pluralityProbabilities[p.name])
                    })).filter(p => p.majorityProb > 0 || p.pluralityProb > 0).sort((a, b) => b.pluralityProb - a.pluralityProb);

                    if (sortedParties.length === 0) {
                        probabilityTableBody.innerHTML = `
                            <tr class="text-center text-gray-500 italic">
                                <td colspan="3" class="px-6 py-4">No parties have a statistical chance of winning a majority or plurality based on the simulation.</td>
                            </tr>
                        `;
                        return;
                    }

                    sortedParties.forEach(p => {
                        probabilityTableBody.innerHTML += `
                            <tr class="hover:bg-gray-50 transition-colors">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0 h-4 w-4 rounded-full" style="background-color: ${p.color};"></div>
                                        <div class="ml-3 text-sm font-medium text-gray-900">${p.name}</div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${p.majorityProb}%
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${p.pluralityProb}%
                                </td>
                            </tr>
                        `;
                    });
                };
                
                const renderCoalitionProbabilities = () => {
                    coalitionMessageDiv.textContent = ''; 
                    const coalitionsToRender = lastSimResults.coalitionsToRender;
                    
                    if (!coalitionsToRender || coalitionsToRender.length === 0) {
                        coalitionTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="5" class="px-6 py-4">No coalitions appear likely based on our simulations.</td></tr>`;
                        updateCoalitionMessage(); 
                        return;
                    }

                    coalitionTableBody.innerHTML = ''; 

                    coalitionsToRender.forEach(coalition => {
                        const ragRating = getRagRating(coalition.parties);
                        const hiddenClass = ((hiddenRed && ragRating === 'red') || (hiddenAmber && ragRating === 'amber')) ? 'hidden-row' : '';
                        
                        let seniorityHtml = '<span class="text-gray-400 text-xs">N/A</span>';
                        const seniorityInfo = lastSimResults.baseCoalitionSeniorityTracker ? lastSimResults.baseCoalitionSeniorityTracker[coalition.baseCoalitionKey] : null;
                        if (seniorityInfo && seniorityInfo.totalOccurrences > 0) {
                            const sortedSeniorityParties = Object.keys(seniorityInfo).filter(pName => pName !== 'totalOccurrences').sort((a, b) => seniorityInfo[b] - seniorityInfo[a]);
                            seniorityHtml = sortedSeniorityParties.map(pName => {
                                const prob = ((seniorityInfo[pName] / seniorityInfo.totalOccurrences) * 100).toFixed(1);
                                return `<div class="flex items-center justify-between text-xs text-gray-600"><span>${pName}:</span> <span>${prob}%</span></div>`;
                            }).join('');
                        }

                        coalitionTableBody.innerHTML += `
                            <tr class="hover:bg-gray-50 transition-colors ${hiddenClass}" data-rag-rating="${ragRating}">
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                    ${coalition.displayName} <span class="text-gray-500 font-normal">(${coalition.averageSeats.toFixed(2)} / ${coalition.maxSeats})</span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center">
                                    <span class="rag-dot rag-${ragRating}"></span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${coalition.majority}%
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${coalition.nearMajority}%
                                </td>
                                <td class="px-6 py-4 text-left text-sm">
                                    ${seniorityHtml}
                                </td>
                            </tr>
                        `;
                    });
                    updateCoalitionMessage(); 
                };
                
                const renderForecastedSeats = (averageSeats) => {
                    if (!averageSeats || Object.keys(averageSeats).length === 0) {
                        forecastedSeatsTableBody.innerHTML = `<tr class="text-center text-gray-500 italic"><td colspan="4" class="px-6 py-4">No data available.</td></tr>`;
                        return;
                    }

                    forecastedSeatsTableBody.innerHTML = '';
                    const sortedParties = parties.map(p => ({
                        ...p,
                        seats: averageSeats[p.name] 
                    })).sort((a, b) => (b.seats?.total || 0) - (a.seats?.total || 0)); 

                    sortedParties.forEach(p => {
                        forecastedSeatsTableBody.innerHTML += `
                            <tr class="hover:bg-gray-50 transition-colors">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0 h-4 w-4 rounded-full" style="background-color: ${p.color};"></div>
                                        <div class="ml-3 text-sm font-medium text-gray-900">${p.name}</div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm text-gray-500">
                                    ${(p.seats?.constituency || 0).toFixed(1)}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm text-gray-500">
                                    ${(p.seats?.regional || 0).toFixed(1)}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-center text-sm font-bold text-gray-900">
                                    ${(p.seats?.total || 0).toFixed(1)}
                                </td>
                            </tr>
                        `;
                    });
                };

                const toggleCoalitionVisibility = (rating) => {
                    const button = document.getElementById(`toggle-${rating}-button`);
                    
                    let isHidden;
                    if (rating === 'red') {
                        hiddenRed = !hiddenRed;
                        isHidden = hiddenRed;
                    } else if (rating === 'amber') {
                        hiddenAmber = !hiddenAmber;
                        isHidden = hiddenAmber;
                    }

                    const colorName = rating.charAt(0).toUpperCase() + rating.slice(1);
                    button.textContent = isHidden ? `Show ${colorName} rated coalitions` : `Hide ${colorName} rated coalitions`;
                    button.classList.toggle(`bg-${rating}-500`, !isHidden);
                    button.classList.toggle('bg-gray-500', isHidden);
                    
                    document.querySelectorAll(`#coalition-table tr[data-rag-rating="${rating}"]`).forEach(row => {
                        row.classList.toggle('hidden-row', isHidden);
                    });
                    updateCoalitionMessage(); 
                };
                
                const showTempMessage = (message, className) => {
                    pollMessageContainer.textContent = message;
                    pollMessageContainer.className = `text-center text-sm font-semibold h-5 mb-2 ${className}`; 
                    setTimeout(() => {
                        pollMessageContainer.textContent = '';
                        pollMessageContainer.className = `text-center text-sm font-semibold h-5 mb-2`; 
                    }, 5000); 
                };

                const renderKeyTakeaways = () => {
                    if (!lastSimResults.averageSeats || Object.keys(lastSimResults.averageSeats).length === 0) {
                        keyTakeawaysList.innerHTML = `<li class="text-gray-500">Simulation could not be run.</li>`;
                        return;
                    }

                    const takeaways = [];
                    const sortedPlurality = parties.map(p => ({
                        name: p.name,
                        plurality: parseFloat(lastSimResults.pluralityProbabilities[p.name]),
                        majority: parseFloat(lastSimResults.majorityProbabilities[p.name])
                    })).sort((a, b) => b.plurality - a.plurality);

                    if (sortedPlurality.length > 0 && sortedPlurality[0].plurality > 0) {
                        const topParty = sortedPlurality[0];
                        let outcomeText = `The simulation suggests that <b>${topParty.name}</b> is most likely to emerge as the largest party, <b>achieving a plurality in ${topParty.plurality}% of simulations</b>.`;
                        if (topParty.majority > 0) {
                            outcomeText += ` They <b>achieve a majority in ${topParty.majority}% of simulations</b>.`;
                        }
                        takeaways.push(outcomeText);
                    }

                    const greenCoalitions = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'green');
                    const amberCoalitions = lastSimResults.coalitionsToRender.filter(c => getRagRating(c.parties) === 'amber');

                    if (greenCoalitions.length > 0) {
                        const topGreen = greenCoalitions[0];
                        let coalitionText = `The most politically viable government option appears to be a <b>${topGreen.displayName}</b> coalition, `;
                        if (topGreen.majority > 0) {
                            coalitionText += `which <b>achieves a majority in ${topGreen.majority}% of simulations</b>.`;
                        } else {
                            coalitionText += `which achieves a near-majority in <b>${topGreen.nearMajority}%</b> of simulations. Near-majorities may become effective majorities with the election of a Presiding Officer, who gives up their party vote.`;
                        }
                        takeaways.push(coalitionText);
                    } else if (amberCoalitions.length > 0) {
                        const topAmber = amberCoalitions[0];
                        let coalitionText = `Forming a majority Scottish Government may be challenging. The most likely coalition, though with some political hurdles, is a <b>${topAmber.displayName}</b> alliance, `;
                        if (topAmber.majority > 0) {
                            coalitionText += `which <b>achieves a majority in ${topAmber.majority}% of simulations</b>.`;
                        } else {
                            coalitionText += `which achieves a near-majority in <b>${topAmber.nearMajority}%</b> of simulations. Near-majorities may become effective majorities with the election of a Presiding Officer, who gives up their party vote.`;
                        }
                        takeaways.push(coalitionText);
                    }

                    const sortedSeats = parties.map(p => ({
                        name: p.name,
                        totalSeats: (lastSimResults.averageSeats[p.name]?.total || 0) 
                    })).sort((a, b) => b.totalSeats - a.totalSeats);

                    if (sortedSeats.length >= 2) {
                        const leader = sortedSeats[0];
                        const second = sortedSeats[1];
                        takeaways.push(`The average result shows <b>${leader.name}</b> as the largest party with <b>${leader.totalSeats.toFixed(1)}</b> seats, ahead of <b>${second.name}</b> with <b>${second.totalSeats.toFixed(1)}</b> seats.`);
                    }

                    takeaways.forEach(text => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = text;
                        keyTakeawaysList.appendChild(listItem);
                    });
                };

                const renderCurrentPollsTable = (polls) => {
                    currentPollsTableBody.innerHTML = ''; 
                    partyHeadersRow.innerHTML = ''; 

                    if (!polls || polls.length === 0) {
                        currentPollsMessageDiv.textContent = 'No current polls available to display.';
                        return;
                    }
                    currentPollsMessageDiv.textContent = ''; 

                    parties.forEach(p => {
                        partyHeadersRow.innerHTML += `<th scope="col" class="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${p.name}</th>`;
                    });
                    parties.forEach(p => {
                        partyHeadersRow.innerHTML += `<th scope="col" class="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">${p.name}</th>`;
                    });

                    // FIX: Changed the loop direction to show the newest poll first.
                    for (let i = 0; i < polls.length; i++) {
                        const poll = polls[i];
                        const row = document.createElement('tr');
                        row.classList.add('hover:bg-gray-50', 'transition-colors');

                        row.innerHTML = `
                            <td class="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${poll.rawDateString || 'No Date'}</td>
                            <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${poll.pollster || 'N/A'}</td>
                            ${parties.map(p => `<td class="px-3 py-2 whitespace-nowrap text-center text-sm text-gray-500">${(poll.constituency[p.name] || 0).toFixed(1)}%</td>`).join('')}
                            ${parties.map(p => `<td class="px-3 py-2 whitespace-nowrap text-center text-sm text-gray-500">${(poll.regional[p.name] || 0).toFixed(1)}%</td>`).join('')}
                        `;
                        currentPollsTableBody.appendChild(row);
                    }
                };

                const updateCoalitionMessage = () => {
                    const visibleRowsInTable = document.querySelectorAll('#coalition-table tr:not(.hidden-row)').length;
                    if (visibleRowsInTable === 0 && lastSimResults.coalitionsToRender.length > 0) {
                        coalitionMessageDiv.textContent = 'No coalitions are visible based on your filter settings.';
                    } else if (lastSimResults.coalitionsToRender.length === 0) {
                        coalitionMessageDiv.textContent = "No coalitions appear likely based on our simulations.";
                    } else {
                        coalitionMessageDiv.textContent = '';
                    }
                };
                
                runSimulationButton.addEventListener('click', updateAndRunSimulation); 
                toggleRedButton.addEventListener('click', () => toggleCoalitionVisibility('red'));
                toggleAmberButton.addEventListener('click', () => toggleCoalitionVisibility('amber'));
                enableTrendApplicationCheckbox.addEventListener('change', updateAndRunSimulation); 

                renderInputs();
                updateAndRunSimulation(); 
            });
        })(); 
    </script>
</body>
</html>
